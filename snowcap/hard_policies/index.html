<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `hard_policies` mod in crate `snowcap`."><meta name="keywords" content="rust, rustlang, rust-lang, hard_policies"><title>snowcap::hard_policies - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"                  integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"    integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "\\(", right: "\\)", display: false},
                {left: "$", right: "$", display: false},
                {left: "\\[", right: "\\]", display: true}
            ]
        });
    });
</script>

<style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../snowcap/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><p class="location">Module hard_policies</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class="location"><a href="../index.html">snowcap</a></p><div id="sidebar-vars" data-name="hard_policies" data-ty="mod" data-relpath="../"></div><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">snowcap</a>::<wbr><a class="mod" href="">hard_policies</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/snowcap/hard_policies/mod.rs.html#18-726" title="goto source code">[src]</a></span></h1><div class="docblock"><h1 id="hard-policies" class="section-header"><a href="#hard-policies">Hard Policies</a></h1>
<p>This module contains all necessary structures and tools to generate hard policies as Linear
Temporal Logic.</p>
<h1 id="policy-language" class="section-header"><a href="#policy-language">Policy Language</a></h1>
<p>This module defines a languate with which to express complex policies. On the top-level, it is
based on <a href="https://en.wikipedia.org/wiki/Linear_temporal_logic">Linear Temporal Logic (LTL)</a>. In
LTL, there exists propositional variables, in the following called conditions, boolean operators
and temporal modal operators.</p>
<h2 id="temporal-modal-operators" class="section-header"><a href="#temporal-modal-operators">Temporal Modal Operators</a></h2>
<p>For the LTL, we use a sequence of states, i.e., the sequence of converged states during
reconfiguration. At each of these states, every propositional variable can either be satsicied
or not. The following operators exist</p>
<ul>
<li>$\phi$ (Now): $\phi$ has to hold in the current state</li>
<li>$\mathbf{X}\ \phi$ (Next): $\phi$ has to hold in the next state</li>
<li>$\mathbf{F}\ \phi$ (Finally): $\phi$ has to hold eventually, somewhere on the subsequent path</li>
<li>$\mathbf{G}\ \phi$ (Globally): $\phi$ has to hold on the entire subsequent path, including the
current state</li>
<li>$\psi\ \mathbf{U}\ \phi$ (Until): $\psi$ has to hold at least until $\phi$ becomes true, which
must hold at the current or any future position. Note, that $\psi$ and $phi$ don't necessarily
need to hold at the same time.</li>
<li>$\psi\ \mathbf{R}\ \phi$ (Release): $\phi$ has to be true until and including the point where
$\psi$ first becomes true. If $\psi$ never becomes true, then $\phi$ must hold forever.</li>
<li>$\psi\ \mathbf{W}\ \phi$ (Weak Until): $\psi$ has to hold at least until $\phi$ becomes true. If
$\phi$ never becomes true, then $\psi$ must hold forever. Note, that $\psi$ and $phi$ don't
necessarily need to hold at the same time.</li>
<li>$\psi\ \mathbf{M}\ \phi$ (Strong Release): $\phi$ has to be true until and including the point where
$\psi$ first becomes true. $\psi$ must hold eventually.</li>
</ul>
<h2 id="logical-operators" class="section-header"><a href="#logical-operators">Logical Operators</a></h2>
<p>The following logical operators are supported</p>
<ul>
<li>$\neg \psi$ (Not)</li>
<li>$\phi \land \psi$ (And)</li>
<li>$\phi \lor \psi$ (Or)</li>
<li>$\phi \oplus \psi$ (xor)</li>
<li>$\phi \Rightarrow \psi$ (Implies)</li>
<li>$\phi \iff \psi$ (If and only if)</li>
</ul>
<h2 id="propositional-variables-conditions" class="section-header"><a href="#propositional-variables-conditions">Propositional Variables (Conditions)</a></h2>
<p>Propositional variables are types of conditions which can be evaluated on the current state (or
when considering the current and last state) of the network (i.e., forwarding state). The
following conditions are possible:</p>
<ul>
<li>$\mathbf{V}_{(r, p, c)}$ (Valid path / Reachability): Router $r$ is able to reach prefix $p$
without encountering any black hole, or forwarding loop. Aitionally, the path condition $c$
must hold, if it is provided.</li>
<li>$\mathbf{I}_{(r, p)}$ (Isolation): Router $r$ is not able to reach prefix $p$, there exists
a black hole on the path.</li>
<li>$\mathbf{V}_{(r, p, c)}^+$ (Reliability): Router $r$ is able to reach prefix $p$ in the case
where a single link fails. This condition is checked by simulating a link failure at every
link in the network. The path condition $c$ (if given) must hold on every chosen path for all
possible link failures.</li>
<li>$\mathbf{T}_{(r, p, c)}$ (Transient behavior): During convergence to reach the current state,
every possible path, that router $r$ might choose to reach $p$ does satisfy the path condition
$c$. Note, that this condition cannot check, that during convergence, no forwarding loop or
black hole may appear. Only the path can be checked.</li>
</ul>
<h2 id="path-condition" class="section-header"><a href="#path-condition">Path Condition</a></h2>
<p>The path condition is a condition on the path. This is an expression, which can contain boolean
operators $\land$ (and), $\lor$ (or) and $\neg$ (not). In addition, the expression may contain
router $r \in \mathcal{V}$, which needs to be reached in the path, an edge $e \in \mathcal{V}
\times \mathcal{V}$, or a positional condition. This positional constraint can be expressed as
a sequence of the alphabet $\lbrace \ast, ?\rbrace \cup \mathcal{V}$. Here, $?$ means any single
router, and $\ast$ means a sequence of any length (can be of length zero) of any router. This
can be used to express more complex conditions on the path. As an example, the positional
condition $[\ast, a, ?, b, c, \ast]$ means that the path must first reach $a$, then visit any
other node, then $b$ must be traversed, immediately followed by $c$. This always matches on the
entire path, and not just on a small part of it.</p>
<h1 id="transient-behavior" class="section-header"><a href="#transient-behavior">Transient Behavior</a></h1>
<p>For transient behavior, we cannot guarantee the absence of black holes or forwarding loops. In
fact, if we would be able, then we would be able to guarantee to the network operator, that the
network is in a more reliable state during reconfiguration, than it is during normal operation.
This obviously makes no sence. Nevertheless, we are able to guarantee that if there exists a
path, then this path will satisfy the specified conditions.</p>
<h2 id="computation-complexity" class="section-header"><a href="#computation-complexity">Computation Complexity</a></h2>
<p>In the following, we use the notation $n = |\mathcal{V}|$ to be the number of routers in the
network. For this algorithm, the following things need to be computed:</p>
<ol>
<li>First, we need to compute the route reachability graph $G_R(r)$ for all routes
$r \in \mathcal{R}$. This graph $G_R$ can be computed using a DFS traversal on the BGP graph
$G_{BGP} = (\mathcal{V}, E_{BGP})$ which takes $O(|\mathcal{V}| + |E_{BGP}|) = O(n^2)$. Hence,
computing all route reachability graphs takes a total of $O(|\mathcal{R}| \cdot n^2)$ time.</li>
<li>Then, we create the forwarding supergraph $G_{pcs} = (\mathcal{V}, E_{pcs})$ in
$O(n \cdot |\mathcal{R}|)$ time.</li>
<li>Finally, we need to perform a DFS traversal on $G_{pcs}$ for every node $v \in \mathcal{V}$.
This takes a total of $O(|\mathcal{V}| + |E_{pcs}|)$ for every node $v \in \mathcal{V}$,
which leads to a complexity $O(|\mathcal{V}| \cdot (|\mathcal{V}| + |E_{pcs}|)) = O(n^3)$.</li>
</ol>
<p>Collecting all these complexities yields the following total time complexity:</p>
<p>$$O(n^2 (n + |\mathcal{R}|))$$</p>
<p>However, if the path conditions cannot be checked using a single DFS traversal (i.e., if they
include positional conditions), then we need to enumerate over all possible paths in the
network (which is, on a DAG $\mathcal{O}(n^2)$), which leads to a total time complexity of:</p>
<p>$$O(2^n + n^2 \mathcal{R})$$</p>
<h2 id="algorithm-description" class="section-header"><a href="#algorithm-description">Algorithm Description</a></h2>
<p>The following algorithm is described on a per-prefix basis. We assume that no router is able
to change the prefix, and that prefixes canot overlap. Based on this assumption, we can safely
check the conditions for every prefix individually. Note, that the constraint on non-overlaping
prefixes can be satisfied by creating multiple prefixes for the different ranges.</p>
<h3 id="definitions" class="section-header"><a href="#definitions">Definitions</a></h3>
<p>In the following, any variable annotated with $\square^-$ means that this is at the state
before the small delta reconfiguration, and $\square^+$ means after the reconfiguration.</p>
<ul>
<li>$\mathcal{S}^\pm$: State of the network before or after the delta reconfiguration.</li>
<li>$v \in \mathcal{V}$: All routers in the network, $\mathcal{V}_{ext} \subset \mathcal{V}$:
external routers</li>
<li>$r \in \mathcal{R}^\pm$: All routes in the network before and after the delta reconfiguration.
Routes can be compared: $r_1 &gt;_v r_2$ means that $r_1$ is preferred over $r_2$ at node $v$
(the node is important here, because IGP cost is one of the criteria to choose a route).
Additionally, we call $\mathcal{R} = \mathcal{R}^- \cup \mathcal{R}^+$ as the set of all
routes before and after the reconfiguration combined.</li>
<li>$rri(r)$: Route reachability of route $r$ is the set of nodes $rri(r) \subseteq \mathcal{V}$,
which may be reached by this route. It is constructed by considering both states before and
after the reconfiguration. The $rri(r)$ respects the rules of route dissemination and route
maps.</li>
<li>$nh(v, r)$: Next hop at node $v$, when router $v$ chooses route $r$.</li>
<li>$pcr(v)$: possibly considered routes: Maps each router in the network to a set of possible
routes, which might get activated and deactivated as transient behavior during convergence of
delta reconfiguration.</li>
<li>$G_{pcr} = (\mathcal{V}, E_{pcr})$: Forwarding supergraph that contains the forwarding state
of every possible intermediate state (and the forwarding state of impossible intermediate
states).</li>
</ul>
<h3 id="algorithm" class="section-header"><a href="#algorithm">Algorithm</a></h3>
<p>The algorithm can be split into several different parts. On a high level, we first extract the
route reachability information for each route (a set of routers which can theoretically learn
this route). Based on this, we generate a forwarding supergraph containing all possible
forwarding graphs. Finally, we perform a graph traversal on this grpah, to verify the path
constraints.</p>
<p>As the first step, we need to prepare the BGP graph $G^\pm_{bgp} = (\mathcal{V}, E^\pm_{bgp},
L_{bgp})$. In this graph, every edge may be either labeled as up $U$, over $O$, or down $D$:
$e \in \lbrace U, O, D \rbrace$. Note, that we need two different graphs, one before and one
after the reconfiguration. both graphs may be different.</p>
<p>As a next step, we compute the the route reachability information $rri(r)$ of every route
$r \in \mathcal{R}$. This information is the set of nodes that may be reached by route r based
on the BGP configuration. Notice, that we compute the reachability of $r \in \mathcal{R}$ on
both $G_{bgp}^-$ and $G_{bgp}^+$, and call the union of the reached nodes as
$rri(r) = reach(G_{bgp}^-) \cup reach(G_{bgp}^+)$. While traversing the bgp graph, if a route
map is encountered from node $u$ to $v$ (either an outgoing route map on node $u$ or an incoming
route map on node $v$, or both), we don't continue traversing node $v$, but we generate a new
route $r'$ and start traversing at node $v$. <em>(Implementation Detail: we generate $G_{bgp}$ and
compute $rri(r)$ both before and after the reconfiguration.)</em></p>
<p>Finally, we build the forwarding supergraph $G_{pcr}$, by looking at all possibly considered
routes $pcr(v) = \lbrace r \in \mathcal{R} \mid v \in rri^-(r) \cup rri^+(r) \rbrace$ and
looking at their next hop, both before and after the reconfiguration. The final graph
$G_{pcr} = (\mathcal{V}, E_{pcr})$ contains an edge from node $u$ to $v$, if and only if there
exists a route $r \in pcr(u)$, which might reach node $u$, and which would cause router $u$ to
send packets to node $v$. More formally,</p>
<p>$$ E_{pcr} = \big\lbrace (u, v) \mid v \in \lbrace nh^-(u, r) \cup nh^+(u, r) \mid r \in
pcr(u) \rbrace \big\rbrace$$</p>
<p>After having constructed the forwarding supergraph, we can check the path conditions of all
nodes in the network. If the condition contains a positional path expression, we have to
enumerate all possible paths, and check the condition on all these paths. This leads to a time
complexity of $\mathcal{O}(2^n)$ (due to finding all possible paths on a directed acyclic
graph). However, if there exists no such condition, we can check all conditions for a single
node in one single graph traversal (in a depth-first-search procedure). This then yields a time
complexity of only $\mathcal{O}(n^3)$.</p>
<p>For the rest of the algorithm explenation, we look at a single node $v$, and assume that the
path conditions do not contain and positional expressions. We continue by transforming the
conditions into Conjunctive Normal Form (CNF). Such expressions are are written as product of
sums, or as an AND of ORs. Let the condition for node $v$ be:</p>
<p>$$(a \lor b \lor \neg c) \land (d \lor e) \land \ldots = \phi_1 \land \phi_2 \land \ldots$$</p>
<p>For each group of expressions, combined with an logical or (in the following called $\phi_i$),
we generate a gorup $g_i$, which we use to remember during DFS traversal if at least one of
these expressions in $g_i$ are satisfied, which means that $phi_i$ is satisfied. Finally, we can
determine, if the entire expression is satisfied, namely then, when all these groups are true.</p>
<p>We perform the DFS traversal. If we encounter a black hole somewhere, we ignore this branch, and
go back without changing anything. <em>TODO: We might be able to do something more intelligent here
but we need to discuss this.</em>. If we encounter a loop, we similarly do nothing, and just ignore
this branch. However, if we reach the target, we update the groups in which this target is in.
Every time, we backtrack because every possible next hop has been explored, we combine the
information of the groups as follows:</p>
<ul>
<li>If every branch satisfies the group, then the current node also satisfies the group.</li>
<li>If at least one branch does not satisfy a group, then this group is also not satisfied for the
current node.</li>
</ul>
<p>This information then propagates back to the root $v$. If all groups are still satisfied, we can
declare the condition as being satisfied. If not, then it is violated.</p>
<h3 id="igp-link-weight-change" class="section-header"><a href="#igp-link-weight-change">IGP Link Weight Change</a></h3>
<p>If the IGP link weight changes, we apply the insight from the paper on <a href="https://ieeexplore.ieee.org/document/4215601">Disruption Free Topology
Reconfiguration in OSPF Networks</a>, in which the
authors prove that there always exists a sequence of link weights which guarantee no forwarding
loops in any transient state.</p>
<p>So, our algorithm generates many different reconfiguraiton expressions to incrementally change
the link weight until we reach the desired value, treating all of these as individual changes.
While preparing the forwarding supergraph, we consider the next hop based on the IGP metric
before and after the reconfiguration.</p>
<h3 id="why-we-cannot-check-for-black-holes" class="section-header"><a href="#why-we-cannot-check-for-black-holes">Why we cannot check for black holes</a></h3>
<p>Using this approach, it is impossible to check if black holes might appear, just by looking at
the state before and after the delta reconfiguration. The reason is that even though the chosen
route has not changed from before to after, it might still disappear temporarily. This is
highlighted by the following two examples:</p>
<p><em>Example 1</em>: Consier the following network and configuration:</p>
<p><img src="https://n.ethz.ch/%7Esctibor/images/TransientStateCounterExample.svg" alt="counter_example" /></p>
<p>In this example, we apply one single modification, that the community of a route is changed from
0 to 666 at router <code>r5</code>. Router <code>r3</code> only allows routes with community 666, while router <code>r4</code>
denies these routes. Finally, <code>r2</code> resets the community to 0, which hides everything that might
happen to the router <code>r1</code>. Depending on the order of messages, <code>r1</code> might not notice any change,
or <code>r1</code> might experience a transient black hole.</p>
<p>This example can be extended to violate arbitrary conditions, such as the necessity of
traversing a specific link. Hence, our algorithm is not able to check for transient black holes,
and the algorithm must always consider all routes, that might be reached by a node.</p>
<p><em>Example 2</em>: Consier the following network and configuration:</p>
<p><img src="https://n.ethz.ch/%7Esctibor/images/TransientStateCounterExample2.svg" alt="counter_example" /></p>
<p>In this example, we add a new route map to router <code>b2</code>. Now, let's consider router <code>rx</code>. First,
notice that the router <code>rx</code> can only receive the route propagated by <code>b1</code> with
<code>local_pref = 120</code>. This route is prefered by router <code>r1</code>, and hence, router <code>rx</code> will receive
this route. As soon as we introduce the modification, there are two orderings which we must
consider:</p>
<ol>
<li>
<p><code>r4</code> receives the new route with the community 666 before <code>r3</code>, and send its new route with
<code>local_pref=150</code> towards <code>r2</code>. Then, <code>r2</code> will forward the route towards <code>r1</code>, which will
then retract the route from <code>e1</code> for <code>rx</code>. Now, we have a black hole at <code>rx</code>.</p>
</li>
<li>
<p><code>r3</code> receives the new route with the community 666 before <code>r4</code>, and sen its new route with
<code>local_pref=200</code> towards <code>r2</code>. Since this route is advertised via peer session, <code>r2</code> will not
notice <code>r1</code> about the change, and hence, <code>rx</code> will still know the same prefix.</p>
</li>
</ol>
<p>In the final state, no matter the ordering of messages, the router <code>r2</code> will prefer the route
form <code>r3</code>, and ignore the one from <code>r4</code>. Hence, router <code>r2</code> does not advertise a route towards
<code>r1</code>, and <code>rx</code> can reach the prefix via <code>e1</code>.</p>
<h3 id="why-we-cannot-improve-the-overapproximation" class="section-header"><a href="#why-we-cannot-improve-the-overapproximation">Why we cannot improve the overapproximation</a></h3>
<p>Using this approach, it is impossible to improve the overapproximation of the forwarding
supergraph, just by looking at the state before and after the delta reconfiguration. The only
way, how the overapproximation can theoretically be improved, is by considering less routes at
any node $v$. However, the two examples above can be extended, such that a much wrose route is
selected temporarily, even if the same better route is selected before and after the delta
reconfiguration. This clearly shows that we cannot go fancy by only considering e.g., routes
that are better than the old known route (if this one is still known after reconfiguration).</p>
</div><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.HardPolicy.html" title="snowcap::hard_policies::HardPolicy struct">HardPolicy</a></td><td class="docblock-short"><p>Linear Temporal Logic</p>
</td></tr></table><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<table><tr class="module-item"><td><a class="enum" href="enum.Condition.html" title="snowcap::hard_policies::Condition enum">Condition</a></td><td class="docblock-short"><p>Condition that can be checked for either being true or false.</p>
</td></tr><tr class="module-item"><td><a class="enum" href="enum.LTLBoolean.html" title="snowcap::hard_policies::LTLBoolean enum">LTLBoolean</a></td><td class="docblock-short"><p>Boolean operator of LTL</p>
</td></tr><tr class="module-item"><td><a class="enum" href="enum.LTLModal.html" title="snowcap::hard_policies::LTLModal enum">LTLModal</a></td><td class="docblock-short"><p>Temporal modal operators of LTL. For reconfiguration purpose, in the last state, we assume that
nothing changes anymore, and every propositional variable does not change its state. See
<a href="https://en.wikipedia.org/wiki/Linear_temporal_logic#Weak_until_and_strong_release">here</a></p>
</td></tr><tr class="module-item"><td><a class="enum" href="enum.PathCondition.html" title="snowcap::hard_policies::PathCondition enum">PathCondition</a></td><td class="docblock-short"><p>Condition on the path, which may be either to require that the path passes through a specirif
node, or that the path traverses a specific edge.</p>
</td></tr><tr class="module-item"><td><a class="enum" href="enum.PolicyError.html" title="snowcap::hard_policies::PolicyError enum">PolicyError</a></td><td class="docblock-short"><p>Hard Policy Error</p>
</td></tr><tr class="module-item"><td><a class="enum" href="enum.Waypoint.html" title="snowcap::hard_policies::Waypoint enum">Waypoint</a></td><td class="docblock-short"><p>Part of the positional waypointing argument</p>
</td></tr></table><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<table><tr class="module-item"><td><a class="trait" href="trait.LTLOperator.html" title="snowcap::hard_policies::LTLOperator trait">LTLOperator</a></td><td class="docblock-short"><p>Operators of LTL</p>
</td></tr></table><h2 id="types" class="section-header"><a href="#types">Type Definitions</a></h2>
<table><tr class="module-item"><td><a class="type" href="type.WatchErrors.html" title="snowcap::hard_policies::WatchErrors type">WatchErrors</a></td><td class="docblock-short"><p>Type alias for comfortable handling of the watch errors</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="snowcap"></div>
    <script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>