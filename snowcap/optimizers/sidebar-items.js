initSidebarItems({"struct":[["DepGroupsOptimizer","DepGroupsOptimizerThis optimizer is similar to `DepGroupsStrategy`, but it also tries to minimize the soft-policies during synthesis. The optimizer starts exactly in the same way as the strategy. It also uses a sub-strategy to solve individual groups. Once a valid solution was found, then we solve each individual dependency group again, but this time using an optimizer. But we also use the state of the network where the group is applied. This way, we can get the best ordering for the sub groups for the valid solution. Once we have found a valid solution, we reset the permutator and try again. During this, we always store the best solution. If we have found 10 new solutions, where no one does improve the best score, we stop the algorithm and return the best one found."],["GlobalOptimizer","Global OptimizerOptimizer that enumerates all possible solutions, and chooses the one which minimizes the soft policies. This optimizer is no longer feasible to use for problems containing 10 or more modifiers. However, it will always return the best possible ordering."],["NaiveMostImportantFirst","Strawman Strategy: Most Important FirstThis strategy is only available if the `\"strawman-strategies\"` feature is enabled!"],["NaiveMostImportantLast","Strawman Strategy: Most Important LastThis strategy is only available if the `\"strawman-strategies\"` feature is enabled!"],["NaiveRandomIBROptimizer","The Naive Random Optimizer with insert before removeThis strategy exists only for evaluation purpose. The idea is, that it tries completely random orderings, until it succeeds. However, it always schedules insert, before update, before remove commands."],["NaiveRandomOptimizer","The Naive Random OptimizerThis strategy exists only for evaluation purpose. The idea is, that it tries completely random orderings, until it succeeds."],["OptimizerTRTA","One Optimizer To Rule Them AllThis is the one optimizer to rule them all, combining the best from the `TreeOptimizer` and the `DepGroupsOptimizer` into one single optimizer."],["TreeOptimizer","Tree OptimizerOptimizer that builds a tree of possible modifiers (based on the hard hard_policy), and traverses it by minimizing the soft policies in each step. To achieve this, this optimizer will, at each step of the tree traversal, compute the cost of all possible next choices (modifiers), and take the one with the lowest cost associated with it. During this, we immediately discard modifiers which would lead to an invalid state, with respect to the given hard hard_policy."]],"trait":[["Optimizer","Infterface for all Optimizers"]]});