initSidebarItems({"struct":[["DepGroupsStrategy","The Dependency Groups Builder StrategyThis strategy tries to build groups which are dependent of oneanother, and tries to solve these independently of all other modifications. The strategy should work really good when there are many different, smaller groups of dependent modifications, which are not dependent between each other."],["NaiveRandomIBRStrategy","The Random Strategy with Insert before RemoveThis strategy exists only for evaluation purpose. The idea is, that it tries completely random orderings, until it succeeds. However, it always shuffles the commands, such that insert will be scheduled before modify, before remove."],["NaiveRandomStrategy","The Naive Random StrategyThis strategy exists only for evaluation purpose. The idea is, that it tries completely random orderings, until it succeeds."],["PermutationStrategy","The Permutation StrategyThe permutation strategy simply tries all possible sequences of the ConfigModifier, and stops as soon as the first valid sequence was found. You must provide one specific `Permutator`, which is used to navigate through the search space."],["PushBackTreeStrategy","The Push-Back Tree StrategyThe Push-Back Tree strategy is based on the `TreeStrategy`. The difference is that once it encounteres a modifier it cannot apply, it will push the modifier to the tail of the list. Then, when finding another modifier that works, the strategy still uses the sequence of remaining modifiers, where the not-working modifier is at the end. Instead of using a list, we obviously use a ring buffer, where moving an element from the front to the back is very cheap."],["StrategyTRTA","One Strategy To Rule Them AllThis is the one strategy to rule them all, combining the best from the `TreeStrategy` and the `DepGroupsStrategy` into one single strategy."],["TreeStrategy","The Tree StrategyThe Tree strategy recursively builds a tree by choosing one of the remaining modifiers and simulating the result. If all policies are satisfied, continue by choosing one of the remaining modifiers. if nont of the remaining modifiers work, then fall back and declare this current modifier as not-satisfying the policies."]],"trait":[["ExhaustiveStrategy","Marking to tell that this strategy is exhaustive."],["GroupStrategy","Trait for a strategy being able to solve groups of modifiers"],["Strategy","Infterface for all strategies"]]});