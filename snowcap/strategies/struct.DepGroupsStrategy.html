<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `DepGroupsStrategy` struct in crate `snowcap`."><meta name="keywords" content="rust, rustlang, rust-lang, DepGroupsStrategy"><title>snowcap::strategies::DepGroupsStrategy - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"                  integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"    integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "\\(", right: "\\)", display: false},
                {left: "$", right: "$", display: false},
                {left: "\\[", right: "\\]", display: true}
            ]
        });
    });
</script>

<style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../snowcap/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><p class="location">Struct DepGroupsStrategy</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#trait-implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Strategy">Strategy</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-RefUnwindSafe">RefUnwindSafe</a><a href="#impl-Send">!Send</a><a href="#impl-Sync">!Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">UnwindSafe</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a><a href="#impl-VZip%3CV%3E">VZip&lt;V&gt;</a></div></div><p class="location"><a href="../index.html">snowcap</a>::<wbr><a href="index.html">strategies</a></p><div id="sidebar-vars" data-name="DepGroupsStrategy" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Struct <a href="../index.html">snowcap</a>::<wbr><a href="index.html">strategies</a>::<wbr><a class="struct" href="">DepGroupsStrategy</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/snowcap/dep_groups/strategy.rs.html#515-533" title="goto source code">[src]</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class="rust struct">pub struct DepGroupsStrategy&lt;S&nbsp;=&nbsp;<a class="struct" href="../../snowcap/strategies/struct.PushBackTreeStrategy.html" title="struct snowcap::strategies::PushBackTreeStrategy">PushBackTreeStrategy</a>&lt;<a class="struct" href="../../snowcap/modifier_ordering/struct.SimpleOrdering.html" title="struct snowcap::modifier_ordering::SimpleOrdering">SimpleOrdering</a>&gt;, P&nbsp;=&nbsp;<a class="struct" href="../../snowcap/permutators/struct.RandomTreePermutator.html" title="struct snowcap::permutators::RandomTreePermutator">RandomTreePermutator</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="../../snowcap/strategies/trait.Strategy.html" title="trait snowcap::strategies::Strategy">Strategy</a> + <a class="trait" href="../../snowcap/strategies/trait.GroupStrategy.html" title="trait snowcap::strategies::GroupStrategy">GroupStrategy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../snowcap/permutators/trait.Permutator.html" title="trait snowcap::permutators::Permutator">Permutator</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>: <a class="trait" href="../../snowcap/permutators/trait.PermutatorItem.html" title="trait snowcap::permutators::PermutatorItem">PermutatorItem</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;,&nbsp;</span> { /* fields omitted */ }</pre></div><div class="docblock"><h1 id="the-dependency-groups-builder-strategy" class="section-header"><a href="#the-dependency-groups-builder-strategy">The Dependency Groups Builder Strategy</a></h1>
<p>This strategy tries to build groups which are dependent of oneanother, and tries to solve these
independently of all other modifications. The strategy should work really good when there are
many different, smaller groups of dependent modifications, which are not dependent between each
other.</p>
<h2 id="properties" class="section-header"><a href="#properties">Properties</a></h2>
<p>This strategy benefits from problems with an <em>immediate effect</em>, since it can massively reduce
the search space if a problem is detected with a relatively small problem. In addition, this
strategy is able do deal with many smaller dependencies (with <em>no immediate effect</em> and a
<em>sparse solution</em>), because it scales with <code>O(g^4)</code> for the number of dependency groups. But
if the groups become larger, it scales with <code>O(n!)</code>.</p>
<h2 id="type-arguments" class="section-header"><a href="#type-arguments">Type Arguments</a></h2>
<ul>
<li><code>S</code> is a <a href="../../snowcap/strategies/trait.GroupStrategy.html"><code>GroupStrategy</code></a>, used to solve a smaller problem
with the group information learned before.</li>
<li><code>P</code> is a <a href="../../snowcap/permutators/trait.Permutator.html"><code>Permutator&lt;usize&gt;</code></a>, used to generate all
permutations of the groups. As soon as a new group is formed, the permutator is reset.</li>
</ul>
<h2 id="overview-of-the-strategy" class="section-header"><a href="#overview-of-the-strategy">Overview of the strategy</a></h2>
<ul>
<li>
<p>Initially, we start by having all modifiers in their own group.</p>
</li>
<li>
<p>Repeat the following procedure, until we have found a valid solution:</p>
<ol>
<li>
<p><em>Choose ordering</em>: Choose a random ordering of the groups, but respect the inter-group
ordering that was determined in step 3.2.</p>
</li>
<li>
<p><em>Check ordering</em>: If the ordering works, then the algorithm ends successfully. If the
ordering has a problem at group <code>gi</code>, then continue at step 3.</p>
</li>
<li>
<p><em>Identify minimal problem</em>: This is a procedure with multiple phases</p>
<ol>
<li>
<p><em>Reduction phase</em>: Go through all groups <code>gj</code> in <code>g1, g2, ..., g(i-1)</code>, and temporatily
remove it from the sequence. Then, retry to execute the sequence. If the resulting
errors are in any way different, we keep the group <code>gj</code> in the ordering. Else, we assume
that this group <code>gj</code> is independent of the problem, and we remove it from the ordering.</p>
</li>
<li>
<p><em>Solving phase</em>: Try to find a solution to the problem, using a different exhaustive
strategy. Here, we try to retain all orerings of the sub-groups to speed up the process
If we have found a valid sequence in which the problem can be found, then we declare the
remaining modifiers as a group, and store it in the solvable sequence. Continue at step</p>
<ol>
<li>If not, then go to the expansion phase at step 3.3.</li>
</ol>
</li>
<li>
<p><em>Expansion phase</em>: If step 3.2 did not result in a solved group, then we expand the
group uner consideration: Continuing form step 3.2, we apply single groups from after
the last one which failed at step 2, and we monitor the changes of errors. If the errors
have changed, then we add this group to the current group under consideration and go
back to step 3.2 to solve the problem. If there exists no modifier group which will
change the errors, we clare this try as failed, we learn nothing from it and continue at
step 1, with a guard that after 10 successive iterations, not finding anything, we abort
the strategy.</p>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="some-details" class="section-header"><a href="#some-details">Some Details</a></h2>
<ul>
<li>
<p>In step 3.1, we don't only need to remove a modifier to see wether it changes the output, but
we also need to move it to the front. Ideally, we would move this modifier to every position,
but we could argue that this is not necessary due to the order in which we look at the groups.
TODO write down a proof or give intuition why this is sufficient.</p>
</li>
<li>
<p>In step 3.1, when the we have found a smaller problem inside the current problem due to the
error being thrown at a different group, we cannot just use recurrsion to further reduce
the problem. This is because, when we use the ordering with the group at the position it was
before, the smaller problem is solvable (because the problem occurred at a different
position). But if we would just remove it and do the recurrsion, it would never solve the
problem later in step 3.2 or 3.3, because there, we add remaining groups, which come after the
problem group. Thus, we need to remove it for the recurrsion and then add it back after it is
finished. However, we need to add it back <em>only</em> when the last element of the ordering before
and after the recurrsion are still the same.</p>
</li>
<li>
<p>In step 3.1, when removing several groups to get the minimal problem, we really want a minimal
problem in terms of groups. If, after removing a modifier, the group changes where the error
appears, we remove all groups after that problematic group. Then, we rerun step 3.1 from the
beginning, because we are now actually searching for a different problem, and groups, which
are identified before, might no longer be part of the problem.</p>
</li>
<li>
<p>In step 3.3, it might happen that adding the new modifier at the beginning of the problem
doesn't change the output, even though it actually is part of the problem. To reduce the
probability of such a case happening, we also try to put the modifier at the end of the
sequence, right before the problematic modifier. (<em>TODO</em>: We should find an example where
putting the modifier at the start or at the end does not change the result, but adding it in
the middle somewhere does.)</p>
</li>
<li>
<p>During step 3.3, we do not allow the problem to be shifted to the newly added group, if that
one cannot be applied at the beginning! However, it might happend that the group solves the
problem if applied at the end, right before the problematic group.</p>
</li>
<li>
<p>When we compare for the errors to change, we cannot simply require that we have solved some
errors, and that the old errors must be a superset of the new errors. As an example, while
reducing the problem, noticing that the new errors introduce new policy errors, we would make
the problem actually bigger by declaring this modifier independent and removing it from the
groups. Since we already check if the position of the error has changed, any introduction of
new errors means that this modifier belongs to the group.</p>
</li>
<li>
<p>As we have shown in the proof of lemma 3 (below), it is necessary that we go back to the
reduction phase, when we the group containing the problematic modifier has changed during
expansion phase. <strong>TODO</strong> Implement this.</p>
</li>
</ul>
<h2 id="future-considerations" class="section-header"><a href="#future-considerations">Future Considerations</a></h2>
<ul>
<li>In step 3.3, we might want to check if adding the modifier somewhere in between does change
the outcome.</li>
<li>As long as we don't check every single position, this strategy is not exhaustive!</li>
<li>In step 3.3, when we notice that a modifier cannot be applied at the beginning, we should
actually check if it changes something when adding it later. The reason is that he might solve
the problem when applied later in the group.</li>
</ul>
<h2 id="finding-dependencies-is-hard" class="section-header"><a href="#finding-dependencies-is-hard">Finding Dependencies is hard</a></h2>
<p><em>If you find too large dependencies, solving them might take too long</em>: Take, as an example, the
<a href="../../snowcap/example_networks/struct.DifficultGadgetComplete.html"><code>DifficultGadgetComplete</code></a>. If we detect a
dependency group like this, and try to solve it, it might take $O(n!)$, even though not all
modifiers are actually dependent, and they can be rearranged however you like. Thus, it is
important that the learned groups are as small as possible.</p>
<p><em>Information from one dependency group cannot be used to solve another dependency group!</em> Assume
that we have a group, for which there exists only one single valid ordering. As an example, take
$m_1$, $m_2$, $m_3$, where this ordering is valid. Further, assume that for the chosen ordering,
inserting $m_4$ at any position results in an invalid ordering. The only valid ordering with
$m_4$ is $m_3$, $m_4$, $m_2$, $m_1$. This means, that we need to solve the problem again with
the larger solution, and we cannot use the information, that we have already obtained by solving
the smaller problem. The <a href="../../snowcap/example_networks/struct.BipartiteGadget.html"><code>BipartiteGadget</code></a> is a good
example where this happens. A dependency group is learned, but it is not complete, and the
solution is invalid when the other modifiers are added. This group is then expanded, and solved
multiple times, always increasing the size.</p>
<p><em>Combining two dependency groups might not reult in another dependency group!</em> Assume that we
have two dependencies: $m_1$ must go before $m_2$, and $m_3$ must go before $m_4$. Further,
assume we notice that performing $m_1$ before $m_3$ breaks the dependency between $m_3$ and
$m_4$, and that now $m_4$ can be inserted into any arbitrary position, if $m_1$ is before $m_3.
This shows, that having learned two dependency groups, the combination of them might not be a
strict dependency group.</p>
<h3 id="how-this-strategy-deals-with-these-problems" class="section-header"><a href="#how-this-strategy-deals-with-these-problems">How this strategy deals with these problems</a></h3>
<p>The strategy is very conservative, when adding new modifiers to a group. We always extend the
group, in which the problematic modifier resides. Because if a modifier causes the problem, it
must also be a part of the new dependency group. Any other modifier, that survives the
reduction phase satisfies one of the following conditions:</p>
<ol>
<li>Removing it from the ordering solves the problem $\rightarrow$ It changes the outcome of the
group.</li>
<li>Removing it from the ordering changes the problematic modifier. In this case, we reduce the
problem by only considering this smaller problem. Then, we recursively restart the reduction
phase, to continue removing all modifiers that no longer are necessary for the group.</li>
<li>Removing it from the ordering changes the problems that occur. The chance for this modifier
being a part of the group is large. There might be cases, in which a modifier never causes
the problem, but only changes how it manifests itself as problems in the network. However,
it is very hard to see this withouth trying all possible orderings. Thus, adding it to the
group is a reasonable thing to do.</li>
</ol>
<p>Thus, we only learn groups, which are somehow dependent. However, assume that we have already
learned the two incomplete dependency groups $A$ and $B$. Now, we notice that $A$ must happen
before $B$. Combining $A$ and $B$ might result in a modifier no longer being a dependency in the
sense that there exists no ordering, in which rearranging that modifier will change the outcome
of the ordering (even if this was previously the case in its smaller dependency group $A$ or
$B$). But still, one might say that it is remains dependent of $A \cup B$, because either $A$ or
$B$ was dependent on it.</p>
<h3 id="worst-cases" class="section-header"><a href="#worst-cases">Worst Cases</a></h3>
<p>Consider the <a href="../../snowcap/example_networks/struct.BipartiteGadget.html"><code>BipartiteGadget</code></a>. There exists a case,
where we have found an incomplete dependency group, that contains the following
modifiers:</p>
<ul>
<li>All sessions from <code>tI</code> to <code>xI</code></li>
<li>All sessions from <code>rI</code> to <code>bI</code>, except one at <code>I = 1</code> will be removed</li>
</ul>
<p>In this case, every ordering where the session from <code>t0</code> to <code>x0</code> is established first, will be
valid (which is what we actually want to find out), but also every ordering, where the session
<code>t1</code> to <code>x1</code> is added first (which is wrong when considering all modifiers). Assume, that the
ordering learned is one where the session <code>t1</code> to <code>x1</code> is added first, and the session from <code>t0</code>
to <code>x0</code> is added later. Then, in a subsequent iteration, the algorithm notices that the removal
of session <code>r1</code> to <code>b1</code> also is a part of the problem. Now, both orderings are invalid, where
the new modifier is added in the beginning or at the end, and thus, we need to recompute the
entire problem, and brute-force it.</p>
<p>This problem can be made even worse, when considering that there is no valid solution, and we
need to expand the problem multiple times, without finding any solution. In this case, finding
a solution takes:</p>
<p>$$\sum_{i=0}^n O(i!) = O(n!)$$</p>
<h1 id="proof-that-no-learned-dependency-group-is-too-large" class="section-header"><a href="#proof-that-no-learned-dependency-group-is-too-large">Proof that no learned dependency group is too large</a></h1>
<p><em>Theorem 1</em>: The <code>DepGroupsStrategy</code> does only learn weak dependency groups.</p>
<p>For the proof, we interchange single modifiers and entire modifier groups, for which we already
know a valid ordering, and which we always keep together in this valid ordering. We first need
to define some terms before we can proof the theorem:</p>
<ul>
<li>
<p><strong>Configuration</strong>: A configuration $C$ is a tuple $(\mathcal{G}, \mathcal{C}, \mathcal{S})$,
where $\mathcal{G}$ denotes the network topology, $\mathcal{C}$ denotes a network wide
configuration and $\mathcal{S}$ denotes a network state.</p>
</li>
<li>
<p><strong>Configuration Modification</strong>: A configuration modification $m$ is a single modification of the
network-wide configuration $\mathcal{C}$ Based on a configuration $C$, applying a modification
$m$ is expressed as $C \cdot m = C'$, which results in a different configuration $C'$. Notice,
that $C' = (\mathcal{G}, \mathcal{C}', \mathcal{S}')$. Even though this operation seems to be
cumulative in most cases, this is not always the case (see the
<a href="../../snowcap/example_networks/struct.DifficultGadgetMinimal.html">Unstable Gadget</a>).</p>
</li>
<li>
<p><strong>Policies</strong>: The Policies $\mathcal{P}$ is a set of hard-policies that need to be satisfied for
some state $\mathcal{S}$ of configuration $C$. This fact is denoted by $C \vdash \mathcal{P}$.</p>
</li>
<li>
<p><strong>Valid Ordering</strong>: The ordering $o$ of a set of modifiers $D = {m_1, m_2, \ldots, m_n }$ on
configuration $C$ under policy $\mathcal{P}$ is valid, if and only if $\forall\ x \leq n: C
\cdot m_{o(1)} \cdot m_{o(2)} \cdot \ldots \cdot m_{o(x)} \vdash \mathcal{P}$.</p>
</li>
<li>
<p><strong>Similar Ordering</strong>: A modifier ordering $o'$ of modifiers $M = {m_1, \ldots, m_n}$ is
similar to $o$ with respect to a subgroup of modifiers $M' \subseteq M$, $|M'| &gt; 0$, if this
subgroup $M'$ is moved inside of $o$. During this transformation, the relative ordering of $x$
and $y$ must be preserved for all pairs $x, y \in M'$ and for all pairs $x, y \in M \setminus
M'$. The relative ordering of $x$ and $y$ must not be preserved if and only if $x \in M'$ and
$x \in M \setminus M'$.</p>
</li>
<li>
<p><strong>Problematic Modifier</strong> Given a set of modifiers $M$, an invalid ordering $o$, a configuration
$C$ and a policy $\mathcal{P}$, let $x \leq n$ be the smallest number, for which $C \cdot
m_{o(1)} \cdot \ldots \cdot m_{o(x)}$ does not satisfy $\mathcal{P}$. Then, $m_x$ is called
the problematic modifier of $M$ with $o$ on $C$ under $\mathcal{P}$.</p>
</li>
<li>
<p><strong>Critical Group</strong>: A modifier group $M' \subset M$ is critical for the set of modifiers $M =
(m_1, \ldots, m_n)$ on $C$ under $\mathcal{P}$, if at least one of the following conditions
apply:</p>
<ol>
<li>There exaists a valid ordering $o$, and a similar ordering $o'$ with respect to $M'$ which
is not valid. In other words, there exists a valid ordering where moving the group $M'$
around will result in an invalid ordering somewhere.</li>
<li>There exists an invalid ordering $o$, and a similar ordering $o'$ with respect to $M'$,
where the resulting error of $o$ and $o'$  is different, or the problematic modifier has
changed.</li>
</ol>
</li>
<li>
<p><strong>Dependency Group</strong>: A set of modifiers $D = { m_1, m_2, \ldots, m_n }$ is called a
dependency group on configuration $C$ under policy $\mathcal{P}$ if the following holds:</p>
<ol>
<li>There exists a <em>valid ordering</em> $o$ for $D$ on $C$ under $\mathcal{P}$.</li>
<li>Every subgroup $M' \subset D$, with $|M'| &gt; 0$ is <em>critical</em> for $D$ on $C$ under
$\mathcal{P}$.</li>
</ol>
</li>
<li>
<p><strong>Weak Dependency Group</strong>: A set of modifiers $D' \subseteq D$ is a weak dependency group if it
is a subset of a dependency group $D$.</p>
</li>
</ul>
<p><em>Observation 1</em>: Any ordering $\tilde{o}$ is valid, if it is the beginning of a valid ordering
$o$.</p>
<p><em>Observation 2</em>: If any ordering $o$ is invalid, any other ordering $\tilde{o}$ is also invalid
if it starts with the same sequence of modifiers, up to and including the problematic modifier.</p>
<p><em>Observation 3</em>: Let $A \subset M$ and $B \subset M$ be two subsets of $M$, which are disjoint
($A \cap B = \emptyset$). Let $o$ be an ordering, and $o'$ be a similar ordering of $o$ with
respect to $A$. Then, we construct an ordering $o_B$, similar to $o$, by moving $B$ to the
beginning or to the end, and we construct $o'_B$, similar to $o'$, by moving $B$ to the
beginning or the end. Then, $o_B$ and $o'_B$ are still similar with respect to $A$.</p>
<p><em>Lemma 1</em>: Let $A$ be a critical group to the set of modifiers $M$, and let $B$ be a
non-critical group to $M$. Then, $A$ is also critical to $M \setminus B$.</p>
<p><em>Proof of Lemma 1</em>: There are two cases, why $A$ is critical to $M$. We need to proof the fact
for the following three cases:</p>
<ol>
<li>There exists a valid ordering $o$ of $M$, and an invalid, and similar ordering $o'$ to $o$
with respect to $A$. In this case, rearranging $B$ in $o$ does not change the fact that $o$
is valid, and rearranging $B$ in $o'$ does not make the ordering valid. Also, in both $o$ and
$o'$, the ordering of $B$ is valid (which can be quickly shown by moving $B$ to the beginning
of $o$, and using the Observation 1). Thus, we generate $o_B$ by moving $B$ to the end of
$o$, and we generate $o'_B$ by moving $B$ to the end of $o'$. Notice, that no modifier in $B$
can be the problematic modifier of $o'_B$, since (a) the relative ordering of $B$ is valid,
and (b) rearranging $B$ cannot change the problematic modifier. Thus, we have a valid
ordering $o_B$, and an invalid, similar ordering $o'_B$ with respect to $A$, which shows that
$A$ is still critical to $M \setminus B$.</li>
<li>There exists an invalid ordering $o$ for $M$, and an invalid, and similar ordering $o'$ to
$o$ with respect to $A$, which has a different error. Similarly to the case 1, we can
generate similar orderings to $o$ and $o'$ by moving $B$ to the end. This does not change
the error of $o$ and $o'$. Thus, they still have a different error, and they still are
similar (see Observation 3), which shows that $A$ is still critical to $M \setminus B$.</li>
<li>There exists an invalid ordering $o$ for $M$, and an invalid, and similar ordering $o'$ to
$o$ with respect to $A$, which has a different problematic modifier. Notice, that the new
problematic modifier cannot be in $B$ (by applying the same proof as in case 1). Again, by
applying the same method as in case 1, we can move the modifier $B$ to the end without
changing the problematic modifier. Thus, the resulting ordering still has two different
problematic modifiers, and hence, $A$ is still critical to $M \setminus B$.</li>
</ol>
<p style=text-align:right;">$\square$</p>
<p><em>Lemma 2</em>: Let $A$ and $B$ be two dependency grups. If $A$ can be applied before $B$, but
$B$ cannot be applied before $A$, then $A \cup B$ forms a dependency group.</p>
<p><em>Proof of Lemma 2</em>: <strong>TODO</strong> This is not the case based on the current definition of a
dependency group. But on a higher level, it should definately be the case. Thus, we might
need to change the definition, such that this is included. For the following, we will just
assume that this is true.</p>
<p><em>Lemma 3</em>: After the reduction phase of the algorithm, the resulting group is a weak dependency
group.</p>
<p><em>Proof of Lemma 3</em>: In the following, we will call $M_i$ the group under consideration at
iteration $i$. We will show that at each iteration of the reduction phase, if a group $A$
survives, it is critical to $M_i$. This suffices, because we know from Lemma 1, that if we
remove a non-critical group form $M_i$, the group $A$ is still critical to $M_{i+1}$. And if
we remove a critical group to $M_i$, then the resulting group $M_{i+1}$ is a weak dependency
group. By recursively applying this fact, we can see that what remains after all $k$ iterations
is a weak dependency group.</p>
<p>Now, we will show that at each iteration of the reduction phase, if group $A$ survives, it is
critical to $M_i$. There are three cases in which $A$ remains:</p>
<ol>
<li>Removing $A$ solves the problem. Let $o$ be the ordering before removing $A$, which we know
is invalid. Let $o_A$ be the ordering where $A$ is moved to the back of $M_i$. Since removing
$A$ solves the problem, we know that either $o_A$ is valid, or in $o_A$, the problematic
modifier is in $A$. If $o_A$ is valid, then we know that $A$ is critical to $M_i$. If the
problematic modifier is in $A$, then we also know that $A$ is critical to $M_i$, because
previously, the problematic modifier was not in $A$ (else, we would not try to remove $A$
from $M_i$ during reduction phase).</li>
<li>Removing $A$ changes the problem. Again, let $o$ be the ordering before removing $A$, which
we know is invalid. Let $o_A$ be the ordering where $A$ is moved to the back of $M_i$. With
Observation 2, we can see that $o_A$ produces the same problem at the same problematic
modifier as $o$, with $A$ removed. Thus, $A$ is critical to $M_i$.</li>
<li>Removing $A$ changes the problematic modifier. By applying the same argument as in case 2,
$A$ is critical to $M_i$. However, notice that we recursively restart the reduction phase,
and recheck all previously determined groups if they are still critical.</li>
</ol>
<p style=text-align:right;">$\square$</p>
<p><em>Lemma 4</em>: During expansion phase, starting form a weak dependency group $M_1$, we only add
critical groups.</p>
<p><em>Proof of Lemma 4</em>: Again, there are several different cases in which a modifier group $A$ is
added to the current group $M_i$ at iteration $i$.</p>
<ol>
<li>Inserting the group $A$ either at tbe beginning or at the end of the ordering, right before
the current problematic group, does solve the problem. Let $o$ be the ordering before
inserting $A$ into the ordering, and $o'$ the ordering where $A$ is inserted. Notice, that we
can extend $o$ by applying $A$ at the end. This does not change the problem, since the
problematic modifier happens before $A$ is applied. Thus, $o'$ and $o$ are similar with
respect to $A$, and thus, $A$ is critical to $M_i$.</li>
<li>Inserting the group $A$ either at the beginning or at the end of the ordering, right before
the current problematic group, does change the error. Following the same argumentation of
case 1, we can see that $A$ is critical to $M_i$.</li>
<li>Inserting the group $A$ either at the beginning or at the end of the ordering, right before
the current problematic group, does change the problematic modifier. Same as for case 1 and
2, we know that $A$ is critical to $M_i$. However, since we now reduce $M_i$ to only include
all groups up to the group containing the problematic modifier, we need to rerun the
reduction phase, since the resulting group might no longer be a weak dependency group.
<strong>TODO</strong> implement this in the code.</li>
</ol>
<p>Based on Lemma 2, we know that the expanded group $A \cup M_i = M_{i+1}$ is also a weak
dependency group. This proves this lemma.</p>
<p style=text-align:right;">$\square$</p>
<p><em>Proof of Theorem 1</em>: By using Lemma 3 and 4, we can see that every group, which is added to the
set of groups has both a valid ordering, and is a (weak) dependency group.</p>
<p style=text-align:right;">$\square$</p>
<h2 id="reason-why-this-strategy-is-not-exhaustive" class="section-header"><a href="#reason-why-this-strategy-is-not-exhaustive">Reason why this strategy is not exhaustive</a></h2>
<p>Let $M = \lbrace m_1, m_2, m_3, m_4 \rbrace$. Assume that there are the following two
dependencies:</p>
<ol>
<li>$(m_1, m_2)$: This is a dependency, which has an immediate effect if $m_2$ is applied before
$m_1$.</li>
<li>$(m_1, m_3, m_2, m_4)$: This dependency has no immediate effect. If $m_4$ is applied, and all
other modifiers are not applied before in the correct order, then the policy is no longer
satisfied, with always the exact same reason.</li>
</ol>
<p>In the following, we argue that there are cases in which the <code>DepGroupsStrategy</code> cannot solve the
problem. for this, we need to consider two points:</p>
<ol>
<li>Before we have learned anything, we have the following cases:
<ol>
<li>Both $m_1$ and $m_2$ are before $m_4$. In this case, no matter the ordering or $m_1$ and
$m_2$, we will learn that $m_2$ is dependent on $m_1$ (during reduction phase if $m_1$
is before $m_2$, or during expansion phase if $m_2$ is before $m_1$).</li>
<li>$m_2$ is before $m_4$. In this case, the same happens as in case 1.</li>
<li>$m_1$ is before $m_4$. In this case, the same happens as in case 4.</li>
<li>$m_4$ is before both $m_1$ and $m_2$. In this case, it fails at $m_4$, and the reduciton
phase will result in $m_4$ being the only modifier left. Then, the expansion phase will
have no effect.</li>
</ol>
</li>
<li>When we have learned dependency $(m_1, m_2)$, we cannot learn anything anymore. Every
reduction phase will result in $m_4$ begin the only modifier left. Then, the expansion
phase will not find anything, because the problem is always the same if not in the single
correct ordering.</li>
</ol>
<p>The next question is, what is the probability of <code>DepGroupsStrategy</code> finding a valid solution.
For this, we need to count the number of possible orderings, in which the algorithm will find
dependency $(m_1, m_2)$, which means the algorithm will fail, and the number of orderings in
which the algorithm finds the valid solution. Out of the possible 24 different orderings, only 1
will result in the algorithm succeeding. However, there are 11 orderings in which the algorithm
will learn the dependency $(m_1, m_2)$. All other 12 cases we can ignore, because these
orderings will just cause the algorithm to choose a different ordering and try again. This leads
to a 9% probability of success.</p>
<p>The question is now, can we find an example where this case happens?</p>
<h2 id="test-case-reduction--delta-debugging" class="section-header"><a href="#test-case-reduction--delta-debugging">Test Case Reduction / Delta Debugging</a></h2>
<p>In test Case Reduction, we try to reduce a problem in a computer program to the minimal set,
which reproduces the same error, in order for the programmer to see the problem more easily and
fix the bug, without being overwhelmed by information.</p>
<p>We actually do a similar thing in this strategy, by trying to find the minimal set of
modifications that cause a certain problem, and then, we try to fix it. The following are the
similarities, i.e., how we can reformulate our problem to make it more similar to Test Case
Reduction:</p>
<ul>
<li>Our oracle is the network simulator. Obviously, this oracle is not perfect, because devices in
the real world might behave differently. However, when we just consider the reduction phase,
and how we reduce the problem to a dependency group, we may argue that the oracle is perfect,
since it is both the oracle and the &quot;real world&quot; (only for this case).</li>
<li>As in Case Reduction, we wish to keep only those modifiers where we know are part of the
dependency group. This is similar to Case Reduction, where an example is minimized, in order
to be better understood.</li>
</ul>
<p>However, there are some key differences:</p>
<ul>
<li>In our case, the ordering of the modifiers can be chosen, and does certainly matter to the
output of the oracle. Thus, several ideas cannot be directly applied, because the problem is
not agnostic to the ordering. On way in which this fact materializes itself is that we cannot
do canonicalization (bringing the ordering into canonical form), because changing the order
will most likely change the result.</li>
<li>Our oracle is better than for case reduction. The oracle tells us which modifier caused the
problem and what part of the network caused the error. We may use this insight to improve
our algorithms.</li>
<li>In Test Case Reduction, one usually needs an ordering of the reduced test cases. Usually,
you would take something like <a href="https://en.wikipedia.org/wiki/Shortlex_order">Shortlex order</a>,
which prefers short test cases over long ones. In our case, however, one might argue that we
need to know about all these reduced orerings. If they are disjoint, then we need both of
them, and if they are not disjoint, then we probably need to merge them.</li>
<li><a href="https://en.wikipedia.org/wiki/Delta_debugging">Delta Debugging</a> cannot be applied directly
due to the fact that the ordering matters. Rearranging can completely change the outcome.
Only checking the second part also makes no sense, if we never reach this point, and if the
modifications are applied on a different state of the network.</li>
<li>The input is not a series of bytes, but a set of modifiers. These modifiers are (for now)
constant, and cannot be changed by the procedure. Also, our problem is different from the one
checking parsers (as demonstrated <a href="https://www.fuzzingbook.org/html/Reducer.html">here</a>). For
parsers, the reduction passes never change the ordering of the input, but only remove certain
parts of the input.</li>
</ul>
<p>Compared to some <a href="https://www.drmaciver.com/2019/01/notes-on-test-case-reduction/">notes</a> on
test case reduction, we may be able to improve the algorithm by utilizing the following points:</p>
<ol>
<li>
<p><strong>Cache oracle results</strong> using bloom filters. This may be necessary to do if simulating the
network becomes expensive. We might store different orderings of modifiers, which we know
cause problems, and where these problems occur, thus reducing the total amount of simulation
time. Since we cannot reduce an ordering into canonical form, and store it in this way into
the bloom filter, caching might not yield a big benefit in our case, especially since we use
permutators to never try the same ordering multiple times.</p>
</li>
<li>
<p>Organize the code into <strong>Reduction Passes</strong>: One reduction pass is a function, which changes
a small thing of the current modifier ordering, like removing one, or reordering it.
Currently, this is somewhat distributed around the code. One reduction pass may invoke the
oracle a multiple times. A fix-point is reached if no change is possible in this reduction
pass. We need to ask the following questions:</p>
<ul>
<li>What reductions to try when the pass fails to reduce the current ordering?</li>
<li>What reductions to try when the pass succeeds in reducing the current ordering?</li>
<li>In what order wo we try to perform reductions?</li>
</ul>
</li>
<li>
<p>One might argue, that we can <strong>use</strong> the idea <strong>directly</strong>: Starting from an invalid ordering
from the beginning, we might want to reduce it just to the minimal set of modifiers. During
the reduction phase, we might want to try to find the smallest set of already learned groups,
that cause the problem. As soon as we have found a minimal problem, then we can try to solve
it by reordering, or by extending it with additional modifiers.</p>
<p>We can assume, that the algorithm will first just find those modifiers, which cannot be
applied by their own. But this is ok, since we wish to keep the dependencies as small as
possible. However, it might get more difficult to extend the problem again in order to find
a valid ordering.</p>
<p>Thus, this change would only result in a more aggressive reduction phase, which might also
find completely different problems (but if finds problems).</p>
</li>
<li>
<p>Perform the reduction in a <strong>Random Order</strong>: As suggested by the
<a href="https://www.drmaciver.com/2019/01/notes-on-test-case-reduction/">notes</a>, performing the
reduction in a random order is often a good idea. Also, one should try to change more than
just one thing during the reduction phase, to reduce the total running time from $O(n)$ down
to $O(\log n)$.</p>
</li>
</ol>
<p>Obviously, we can replace our reduction phase with proper methods from test case reduction.
However, early experiments have shown that the reduction only takes negligible time, compared to
finding a valid solution for a group.</p>
</div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><h3 id="impl-Strategy" class="impl"><code class="in-band">impl&lt;S, P&gt; <a class="trait" href="../../snowcap/strategies/trait.Strategy.html" title="trait snowcap::strategies::Strategy">Strategy</a> for <a class="struct" href="../../snowcap/strategies/struct.DepGroupsStrategy.html" title="struct snowcap::strategies::DepGroupsStrategy">DepGroupsStrategy</a>&lt;S, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="../../snowcap/strategies/trait.Strategy.html" title="trait snowcap::strategies::Strategy">Strategy</a> + <a class="trait" href="../../snowcap/strategies/trait.GroupStrategy.html" title="trait snowcap::strategies::GroupStrategy">GroupStrategy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../snowcap/permutators/trait.Permutator.html" title="trait snowcap::permutators::Permutator">Permutator</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>: <a class="trait" href="../../snowcap/permutators/trait.PermutatorItem.html" title="trait snowcap::permutators::PermutatorItem">PermutatorItem</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;,&nbsp;</span></code><a href="#impl-Strategy" class="anchor"></a><a class="srclink" href="../../src/snowcap/dep_groups/strategy.rs.html#535-678" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.new" class="method hidden"><code>fn <a href="../../snowcap/strategies/trait.Strategy.html#tymethod.new" class="fnname">new</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;net: <a class="struct" href="../../snowcap/netsim/struct.Network.html" title="struct snowcap::netsim::Network">Network</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;modifiers: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="../../snowcap/netsim/config/enum.ConfigModifier.html" title="enum snowcap::netsim::config::ConfigModifier">ConfigModifier</a>&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;hard_policy: <a class="struct" href="../../snowcap/hard_policies/struct.HardPolicy.html" title="struct snowcap::hard_policies::HardPolicy">HardPolicy</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;time_budget: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt;<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;Self&gt;, <a class="enum" href="../../snowcap/enum.Error.html" title="enum snowcap::Error">Error</a>&gt;</code><a class="srclink" href="../../src/snowcap/dep_groups/strategy.rs.html#541-574" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Create the strategy</p>
</div><h4 id="method.work" class="method hidden"><code>fn <a href="../../snowcap/strategies/trait.Strategy.html#tymethod.work" class="fnname">work</a>(&amp;mut self, abort: <a class="struct" href="../../snowcap/struct.Stopper.html" title="struct snowcap::Stopper">Stopper</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="../../snowcap/netsim/config/enum.ConfigModifier.html" title="enum snowcap::netsim::config::ConfigModifier">ConfigModifier</a>&gt;, <a class="enum" href="../../snowcap/enum.Error.html" title="enum snowcap::Error">Error</a>&gt;</code><a class="srclink" href="../../src/snowcap/dep_groups/strategy.rs.html#576-672" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Main function to find a valid reconfiguration sequence (if it exists) and return it.
The function also returns the number of sequences that were tested. <a href="../../snowcap/strategies/trait.Strategy.html#tymethod.work">Read more</a></p>
</div><h4 id="method.num_states" class="method hidden"><code>fn <a href="../../snowcap/strategies/trait.Strategy.html#tymethod.num_states" class="fnname">num_states</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a class="srclink" href="../../src/snowcap/dep_groups/strategy.rs.html#675-677" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns the number of states explored by the strategy. <a href="../../snowcap/strategies/trait.Strategy.html#tymethod.num_states">Read more</a></p>
</div><h4 id="method.synthesize" class="method hidden"><code>fn <a href="../../snowcap/strategies/trait.Strategy.html#method.synthesize" class="fnname">synthesize</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;net: <a class="struct" href="../../snowcap/netsim/struct.Network.html" title="struct snowcap::netsim::Network">Network</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;end_config: <a class="struct" href="../../snowcap/netsim/config/struct.Config.html" title="struct snowcap::netsim::config::Config">Config</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;hard_policy: <a class="struct" href="../../snowcap/hard_policies/struct.HardPolicy.html" title="struct snowcap::hard_policies::HardPolicy">HardPolicy</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;time_budget: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;abort: <a class="struct" href="../../snowcap/struct.Stopper.html" title="struct snowcap::Stopper">Stopper</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="../../snowcap/netsim/config/enum.ConfigModifier.html" title="enum snowcap::netsim::config::ConfigModifier">ConfigModifier</a>&gt;, <a class="enum" href="../../snowcap/enum.Error.html" title="enum snowcap::Error">Error</a>&gt;</code><a class="srclink" href="../../src/snowcap/strategies/mod.rs.html#162-187" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Wrapper, that creates the strategy and synthesizes the network update order.</p>
</div></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><h3 id="impl-RefUnwindSafe" class="impl"><code class="in-band">impl&lt;S, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="../../snowcap/strategies/struct.DepGroupsStrategy.html" title="struct snowcap::strategies::DepGroupsStrategy">DepGroupsStrategy</a>&lt;S, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></code><a href="#impl-RefUnwindSafe" class="anchor"></a><a class="srclink" href="../../src/snowcap/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Send" class="impl"><code class="in-band">impl&lt;S&nbsp;=&nbsp;<a class="struct" href="../../snowcap/strategies/struct.PushBackTreeStrategy.html" title="struct snowcap::strategies::PushBackTreeStrategy">PushBackTreeStrategy</a>&lt;<a class="struct" href="../../snowcap/modifier_ordering/struct.SimpleOrdering.html" title="struct snowcap::modifier_ordering::SimpleOrdering">SimpleOrdering</a>&gt;, P&nbsp;=&nbsp;<a class="struct" href="../../snowcap/permutators/struct.RandomTreePermutator.html" title="struct snowcap::permutators::RandomTreePermutator">RandomTreePermutator</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../../snowcap/strategies/struct.DepGroupsStrategy.html" title="struct snowcap::strategies::DepGroupsStrategy">DepGroupsStrategy</a>&lt;S, P&gt;</code><a href="#impl-Send" class="anchor"></a><a class="srclink" href="../../src/snowcap/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Sync" class="impl"><code class="in-band">impl&lt;S&nbsp;=&nbsp;<a class="struct" href="../../snowcap/strategies/struct.PushBackTreeStrategy.html" title="struct snowcap::strategies::PushBackTreeStrategy">PushBackTreeStrategy</a>&lt;<a class="struct" href="../../snowcap/modifier_ordering/struct.SimpleOrdering.html" title="struct snowcap::modifier_ordering::SimpleOrdering">SimpleOrdering</a>&gt;, P&nbsp;=&nbsp;<a class="struct" href="../../snowcap/permutators/struct.RandomTreePermutator.html" title="struct snowcap::permutators::RandomTreePermutator">RandomTreePermutator</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../../snowcap/strategies/struct.DepGroupsStrategy.html" title="struct snowcap::strategies::DepGroupsStrategy">DepGroupsStrategy</a>&lt;S, P&gt;</code><a href="#impl-Sync" class="anchor"></a><a class="srclink" href="../../src/snowcap/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Unpin" class="impl"><code class="in-band">impl&lt;S, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="../../snowcap/strategies/struct.DepGroupsStrategy.html" title="struct snowcap::strategies::DepGroupsStrategy">DepGroupsStrategy</a>&lt;S, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,&nbsp;</span></code><a href="#impl-Unpin" class="anchor"></a><a class="srclink" href="../../src/snowcap/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-UnwindSafe" class="impl"><code class="in-band">impl&lt;S, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="../../snowcap/strategies/struct.DepGroupsStrategy.html" title="struct snowcap::strategies::DepGroupsStrategy">DepGroupsStrategy</a>&lt;S, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a>,&nbsp;</span></code><a href="#impl-UnwindSafe" class="anchor"></a><a class="srclink" href="../../src/snowcap/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><h3 id="impl-Any" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Any" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#131-135" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.type_id" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#132" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div><h3 id="impl-Borrow%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Borrow%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#207-211" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id="impl-BorrowMut%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214-218" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow_mut" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#215" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id="impl-From%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</code><a href="#impl-From%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#545-549" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#546" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-Into%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-Into%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#534-541" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#538" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-TryFrom%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#582-591" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_from" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#588" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-TryInto%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryInto%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#568-577" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error-1" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#574" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-VZip%3CV%3E" class="impl"><code class="in-band">impl&lt;V, T&gt; <a class="trait" href="../../ppv_lite86/types/trait.VZip.html" title="trait ppv_lite86::types::VZip">VZip</a>&lt;V&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../ppv_lite86/types/trait.MultiLane.html" title="trait ppv_lite86::types::MultiLane">MultiLane</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-VZip%3CV%3E" class="anchor"></a><a class="srclink" href="../../src/ppv_lite86/types.rs.html#211-219" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.vzip" class="method hidden"><code>pub fn <a href="../../ppv_lite86/types/trait.VZip.html#tymethod.vzip" class="fnname">vzip</a>(self) -&gt; V</code><a class="srclink" href="../../src/ppv_lite86/types.rs.html#216" title="goto source code">[src]</a></h4></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="snowcap"></div>
    <script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>