// Snowcap: Synthesizing Network-Wide Configuration Updates
// Copyright (C) 2021  Tibor Schneider
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

//! Import functions for importing topology zoo graphml files

use crate::hard_policies::*;
use crate::netsim::config::{
    Config,
    ConfigExpr::{self, *},
};
use crate::netsim::route_map::*;
use crate::netsim::{AsId, BgpSessionType::*, LinkWeight, Network, NetworkError, Prefix, RouterId};
use crate::Error;

use itertools::iproduct;
use log::*;
use petgraph::prelude::*;
use rand::prelude::*;
use std::collections::{HashMap, HashSet, VecDeque};

mod error;
pub use error::ZooTopologyError;

mod gml_parser;

type NodeIdx = NodeIndex<u32>;

/// # ZooTopology
/// This struct can be used to generate a network from a ZooTopology graphml file. In addition, you
/// can set (predictably) random link weights, and generate a (predictably) random iBGP topologies.
///
/// ```rust
/// # use snowcap::topology_zoo::ZooTopology;
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// # let gml_filename: String = format!("{}/test_files/switch.gml", env!("CARGO_MANIFEST_DIR"));
/// let mut t = ZooTopology::new(gml_filename, 42)?;
/// t.randomize_link_weights(100);
/// t.ibgp_spanning_forest(4);
///
/// let mut net = t.get_net();
/// net.set_config(&t.get_config()?)?;
/// t.advertise_prefixes(&mut net, 16, 0.5)?;
/// # Ok(())
/// # }
/// ```
///
/// You can choose from the following iBGP topologies:
/// - Full-mesh
/// - Topology with a single route reflector, and all other routers being clients connected to that
///   route reflector
/// - Spanning forest topology with `num_roots` different root nodes, chosen randomly, and a
///   hierarchie of route reflectors, where each internal non-root node has exactly one parent route
///   reflector.
#[derive(Debug, Clone)]
pub struct ZooTopology {
    rng: StdRng,
    graph: Graph<NodeData, LinkWeight, Undirected, u32>,
    /// The node data of this graph is the node index into the physical graph.
    ibgp_graph: Graph<(), (), Directed, u32>,
    ibgp_roots: HashSet<NodeIdx>,
    /// Every node in this set is in its separate network!
    disconnected: HashSet<NodeIdx>,
    maintenance: HashSet<NodeIdx>,
    create_ibgp_peers: bool,
}

impl ZooTopology {
    /// Return a new ZooTopology instance by reading and parsing the privided GML file. Per default,
    /// it will generate a ZooTopology with 100 prefixes. The iBGP topology is not generated by
    /// default.
    ///
    /// # Panics
    /// Panics if somehow, petgraph does not play along and creates nodes in a wierd order.
    pub fn new(gml_filename: impl AsRef<str>, seed: u64) -> Result<Self, ZooTopologyError> {
        info!("Parsing the file and reading the graph");
        let graph = gml_parser::parse_gml_graph(gml_filename.as_ref())?;
        info!("Successfully read the GML file.");
        // clone the nodes of the physical graph and make sure that the nodes indices are always the same
        let mut ibgp_graph: Graph<(), (), Directed, u32> = Graph::new();
        for _ in graph.node_indices() {
            ibgp_graph.add_node(());
        }

        Ok(Self {
            rng: StdRng::seed_from_u64(seed),
            graph,
            ibgp_graph,
            ibgp_roots: HashSet::new(),
            disconnected: HashSet::new(),
            maintenance: HashSet::new(),
            create_ibgp_peers: true,
        })
    }

    /// This funciton applies a scenario to a topology (including some common configuration). This
    /// function may panic, if the topology does not support the scenario.
    pub fn apply_scenario(
        &mut self,
        scenario: Scenario,
        random_root: bool,
        max_weight: u32,
        num_prefixes: usize,
        prefix_probability: f64,
    ) -> Result<(Network, Config, HardPolicy), Error> {
        let mut net = self.get_net();
        // build initial config

        let (config_a, config_b) = match scenario {
            Scenario::FullMesh2RouteReflector | Scenario::RouteReflector2FullMesh => {
                self.randomize_link_weights(max_weight);
                self.ibgp_full_mesh();
                let config_a = self.get_config()?;

                // build final config with different iBGP topology
                if random_root {
                    self.ibgp_single_route_reflector_random()?;
                } else {
                    self.ibgp_single_route_reflector_most_important()?;
                }
                let config_b = self.get_config()?;
                (config_a, config_b)
            }
            Scenario::DoubleIgpWeight | Scenario::HalveIgpWeight => {
                self.randomize_link_weights(max_weight);
                // build initial config
                if random_root {
                    self.ibgp_single_route_reflector_random()?;
                } else {
                    self.ibgp_single_route_reflector_most_important()?;
                }
                let config_a = self.get_config()?;
                let mut config_b = Config::new();
                for expr in config_a.iter() {
                    config_b.add(match expr.clone() {
                        ConfigExpr::IgpLinkWeight { source, target, weight }
                            if net.get_device(source).is_internal()
                                && net.get_device(target).is_internal() =>
                        {
                            ConfigExpr::IgpLinkWeight { source, target, weight: weight * 2.0 }
                        }
                        e => e,
                    })?;
                }
                (config_a, config_b)
            }
            Scenario::DoubleLocalPref | Scenario::HalveLocalPref => {
                self.randomize_link_weights(max_weight);
                if random_root {
                    self.ibgp_single_route_reflector_random()?;
                } else {
                    self.ibgp_single_route_reflector_most_important()?;
                }
                let config_a = self.get_config()?;
                let mut config_b = config_a.clone();
                let mut order_id = 1;
                for expr in config_a.iter() {
                    let (r_int, r_ext) = match expr {
                        ConfigExpr::BgpSession { source: r_int, target: r_ext, session_type }
                            if session_type.is_ebgp()
                                && net.get_external_routers().contains(r_ext) =>
                        {
                            (r_int, r_ext)
                        }
                        ConfigExpr::BgpSession { source: r_ext, target: r_int, session_type }
                            if session_type.is_ebgp()
                                && net.get_external_routers().contains(r_ext) =>
                        {
                            (r_int, r_ext)
                        }
                        _ => continue,
                    };
                    config_b.add(ConfigExpr::BgpRouteMap {
                        router: *r_int,
                        direction: RouteMapDirection::Incoming,
                        map: RouteMapBuilder::new()
                            .order(order_id)
                            .allow()
                            .match_neighbor(*r_ext)
                            .set_local_pref(200)
                            .build(),
                    })?;
                    order_id += 1;
                }
                (config_a, config_b)
            }
            Scenario::IntroduceSecondRouteReflector | Scenario::RemoveSecondRouteReflector => {
                self.randomize_link_weights(max_weight);
                // set route-reflector topology
                if random_root {
                    self.ibgp_single_route_reflector_random()?;
                } else {
                    self.ibgp_single_route_reflector_most_important()?;
                }
                let config_a = self.get_config()?;
                let root = self
                    .get_roots()
                    .into_iter()
                    .next()
                    .expect("exactly one root must exist!")
                    .to_string();

                if random_root {
                    self.ibgp_two_route_reflectors_one_named_other_random(root.as_str())?;
                } else {
                    self.ibgp_two_route_reflectors_one_named_other_important(root.as_str())?;
                }
                let config_b = self.get_config()?;
                (config_a, config_b)
            }
            Scenario::NetworkAcquisition | Scenario::NetworkSplit => {
                self.randomize_link_weights(max_weight);
                self.acquisition_before(0.1)?;
                let config_a = self.get_config()?;
                let mut t_clone = self.clone();
                t_clone.acquisition_after(0.1, max_weight);
                let config_b = t_clone.get_config()?;
                (config_a, config_b)
            }
            Scenario::DisconnectRouter | Scenario::ConnectRouter => {
                // setup weights and the single route-reflector topology
                self.randomize_link_weights(max_weight);
                if random_root {
                    self.ibgp_single_route_reflector_random()?;
                } else {
                    self.ibgp_single_route_reflector_most_important()?;
                }
                let config_a = self.get_config()?;

                // select a router that is the most important
                let mut possible_routers = self
                    .graph
                    .node_indices()
                    .into_iter()
                    .filter(|x| {
                        !self.ibgp_roots.contains(x)
                            && self
                                .graph
                                .neighbors(*x)
                                .filter(|n| self.graph.node_weight(*n).unwrap().external)
                                .count()
                                == 0
                    })
                    .collect::<Vec<_>>();
                possible_routers.shuffle(&mut self.rng);
                let selected_router = possible_routers
                    .into_iter()
                    .next()
                    .ok_or(ZooTopologyError::TooFewNonBorderRouters)?;
                self.maintenance.insert(selected_router);
                // set all link weights around this router to infinity
                self.graph
                    .edges_directed(selected_router, Direction::Outgoing)
                    .chain(self.graph.edges_directed(selected_router, Direction::Incoming))
                    .map(|e| e.id())
                    .collect::<Vec<_>>() // collect in order to get a mutable reference to graph
                    .into_iter()
                    .for_each(|e| *self.graph.edge_weight_mut(e).unwrap() = LinkWeight::INFINITY);

                let config_b = self.get_config()?;
                (config_a, config_b)
            }
            Scenario::VerifyTransientCondition | Scenario::VerifyTransientConditionReverse => {
                return self.apply_transient_condition_scenario(
                    net,
                    max_weight,
                    scenario.is_inverse(),
                    None,
                );
            }
            // Zibin: Add scenario: Single level RR to Multi-level RR (MultiRR)
            Scenario::MultiRR => {
                self.randomize_link_weights(max_weight);
                // build initial config
                let mut sorted_internal_nodes = self
                    .graph
                    .node_indices()
                    .into_iter()
                    .filter(|x| !self.graph.node_weight(*x).unwrap().external)
                    .collect::<Vec<_>>();
                sorted_internal_nodes.sort_by_key(|x| self.graph.node_weight(*x).unwrap().uid);
                let number_of_internal_nodes = sorted_internal_nodes.iter().count();
                let mut number_cores = number_of_internal_nodes * 0.5 as usize;
                if number_cores < 2 {
                    number_cores = 2;
                }
                self.multi_rr_initial(&sorted_internal_nodes, number_cores)?;
                let config_a = self.get_config()?;
                let mut config_b = Config::new();
                // copy IGP conf
                for expr in config_a.iter() {
                    match expr.clone() {
                        ConfigExpr::IgpLinkWeight { source, target, weight } => {
                            debug!(
                                "Copied IGP link weight {} <-> {}, {:.0}",
                                self.graph.node_weight(source).unwrap().name,
                                self.graph.node_weight(target).unwrap().name,
                                weight
                            );
                            config_b
                                .add(ConfigExpr::IgpLinkWeight { source, target, weight })
                                .unwrap();
                        }
                        _e => (),
                    };
                }

                // assert_eq!(1, 2);
                // target configuration for MultiRR..
                // get most import RR from cores..
                let important = self
                    .graph
                    .node_indices()
                    .into_iter()
                    .filter(|x| !self.graph.node_weight(*x).unwrap().external)
                    .filter(|x| {
                        self.graph.node_weight(*x).unwrap().uid
                            <= self
                                .graph
                                .node_weight(sorted_internal_nodes[number_cores - 1])
                                .unwrap()
                                .uid
                    })
                    .max_by_key(|x| {
                        self.graph
                            .neighbors(*x)
                            .filter(|n| !self.graph.node_weight(*n).unwrap().external)
                            .count()
                    })
                    .ok_or(ZooTopologyError::TooFewInternalRouters)?;
                // add to-RR config to config_b
                for core in 0..number_cores {
                    if self.graph.node_weight(sorted_internal_nodes[core]).unwrap().uid
                        == self.graph.node_weight(important).unwrap().uid
                    {
                        continue;
                    }
                    config_b
                        .add(ConfigExpr::BgpSession {
                            source: important,
                            target: sorted_internal_nodes[core],
                            session_type: IBgpClient,
                        })
                        .unwrap();
                }
                // connect fellow to-RR sessions, same as initial conf
                let mut core_id = 0;
                for client in number_cores..number_of_internal_nodes {
                    config_b
                        .add(ConfigExpr::BgpSession {
                            source: sorted_internal_nodes[core_id],
                            target: sorted_internal_nodes[client],
                            session_type: IBgpClient,
                        })
                        .unwrap();
                    core_id += 1;
                    if core_id >= number_cores {
                        core_id = 0;
                    }
                }
                /////// EBGP
                for external_router in self
                    .graph
                    .node_indices()
                    .into_iter()
                    .filter(|x| self.graph.node_weight(*x).unwrap().external)
                {
                    for neighbor in self.graph.neighbors(external_router) {
                        let ext_net_idx =
                            self.graph.node_weight(external_router).unwrap().net_idx.unwrap();
                        let int_net_idx =
                            self.graph.node_weight(neighbor).unwrap().net_idx.unwrap();
                        trace!(
                            "Add eBGP session: {} --> {}",
                            self.graph.node_weight(int_net_idx).unwrap().name,
                            self.graph.node_weight(ext_net_idx).unwrap().name,
                        );
                        config_b
                            .add(BgpSession {
                                source: ext_net_idx,
                                target: int_net_idx,
                                session_type: EBgp,
                            })
                            .unwrap();
                    }
                }
                (config_a, config_b)
            }
        };

        // inverse the configuration if necessary
        let (config_a, config_b) =
            if scenario.is_inverse() { (config_b, config_a) } else { (config_a, config_b) };

        // apply config A to network
        net.set_config(&config_a)?;

        // advertise the same prefix on every router
        self.advertise_prefixes(&mut net, num_prefixes, prefix_probability)?;

        // prepare the hard polcies
        let hard_policy = match scenario {
            Scenario::ConnectRouter => {
                let prop_vars =
                    iproduct!(net.get_routers().iter(), net.get_known_prefixes().iter())
                        .map(|(r, p)| Condition::Reachable(*r, *p, None))
                        .collect::<Vec<Condition>>();

                let prop_vars_without = prop_vars
                    .iter()
                    .enumerate()
                    .filter(|(_, p)| !self.maintenance.contains(&p.router_id()))
                    .map(|(i, _)| i)
                    .collect::<Vec<_>>();

                let prop_vars_with = (0..prop_vars.len()).collect::<Vec<_>>();

                HardPolicy::until_globally(prop_vars, &prop_vars_without, &prop_vars_with)
            }
            Scenario::DisconnectRouter => {
                let prop_vars =
                    iproduct!(net.get_routers().iter(), net.get_known_prefixes().iter())
                        .map(|(r, p)| Condition::Reachable(*r, *p, None))
                        .collect::<Vec<Condition>>();

                let prop_vars_without = prop_vars
                    .iter()
                    .enumerate()
                    .filter(|(_, p)| !self.maintenance.contains(&p.router_id()))
                    .map(|(i, _)| i)
                    .collect::<Vec<_>>();

                let prop_vars_with = (0..prop_vars.len()).collect::<Vec<_>>();

                HardPolicy::until_globally(prop_vars, &prop_vars_with, &prop_vars_without)
            }
            _ => {
                HardPolicy::reachability(net.get_routers().iter(), net.get_known_prefixes().iter())
            }
        };

        Ok((net, config_b, hard_policy))
    }

    /// Zibin: Add member function ->
    /// Construct initial configuration for MultiRR Case
    pub fn multi_rr_initial(
        &mut self,
        sorted_internal_nodes: &Vec<NodeIndex>,
        core_node_count: usize,
    ) -> Result<&mut Self, ZooTopologyError> {
        // clear ibgp graph
        self.ibgp_roots.drain();
        self.ibgp_graph.clear_edges();

        let internal_node_counts = sorted_internal_nodes.iter().count();

        let core = sorted_internal_nodes[0..core_node_count].to_vec();
        self.ibgp_roots = core.into_iter().collect();

        let mut core_id = 0;
        for client in core_node_count..internal_node_counts {
            self.ibgp_graph.add_edge(
                sorted_internal_nodes[core_id],
                sorted_internal_nodes[client],
                (),
            );
            core_id += 1;
            if core_id >= core_node_count {
                core_id = 0;
            }
        }

        Ok(self)
    }

    /// Applies the transient condition scenario, and returns (if possible) the tuple `Network`,
    /// `Config` and `HardPolicy`. If the arguemnt `external_routers` is given, their values
    /// represent the following:
    /// 1. Name of the router configured with local-pref 100
    /// 2. Name of the router configured with local-pref 50
    /// 3. Name of the router added (or removed) during reconfiguration.
    ///
    /// This function is called when calling [`ZooTopology::apply_scenario`] with the scenario
    /// [`Scenario::VerifyTransientCondition`] or [`Scenario::VerifyTransientConditionReverse`]
    pub fn apply_transient_condition_scenario(
        &mut self,
        mut net: Network,
        max_weight: u32,
        reverse: bool,
        external_routers: Option<(&str, &str, &str)>,
    ) -> Result<(Network, Config, HardPolicy), Error> {
        // first, randomize the link weights
        self.randomize_link_weights(max_weight);
        // then generate the 3-RR topology
        self.ibgp_general_route_reflectors(3)?;
        // generate the config, but without any external router configuration
        let mut c1 = self.prepare_config(false)?;
        // select three distinct border routers (to do this, iterate over all routers and filter out
        // the ones that are external, and those that have no neighbor that is an external router.)
        let (ext_lp100, ext_lp50, ext_new) = match external_routers {
            None => {
                let mut border_routers = self
                    .graph
                    .node_indices()
                    .into_iter()
                    .filter(|x| !self.graph.node_weight(*x).unwrap().external)
                    .filter(|x| {
                        self.graph
                            .neighbors(*x)
                            .find(|n| self.graph.node_weight(*n).unwrap().external)
                            .is_some()
                    })
                    .collect::<Vec<_>>();
                if border_routers.len() < 3 {
                    return Err(Error::ZooTopologyError(ZooTopologyError::TooFewExternalRouters));
                }
                border_routers.shuffle(&mut self.rng);
                // generate an iterator that iterates over each border routers and returns the first
                // external neighbor
                let mut ext = border_routers.into_iter().map(|x| {
                    self.graph
                        .neighbors(x)
                        .filter(|n| self.graph.node_weight(*n).unwrap().external)
                        .next()
                        .unwrap()
                });
                (ext.next().unwrap(), ext.next().unwrap(), ext.next().unwrap())
            }
            Some((n_lp100, n_lp50, n_new)) => {
                let names = [n_lp100, n_lp50, n_new];
                let mut ext = names.iter().map(|ext| {
                    self.graph
                        .node_indices()
                        .into_iter()
                        .filter(|x| self.graph.node_weight(*x).unwrap().name == **ext)
                        .next()
                        .unwrap()
                });
                (ext.next().unwrap(), ext.next().unwrap(), ext.next().unwrap())
            }
        };

        // configure neighbor of ext_lp50 to set lp to 50
        let int_lp50 = self.graph.neighbors(ext_lp50).next().unwrap();
        let ext_net_idx = self.graph.node_weight(ext_lp50).unwrap().net_idx.unwrap();
        let int_net_idx = self.graph.node_weight(int_lp50).unwrap().net_idx.unwrap();
        c1.add(BgpRouteMap {
            router: int_net_idx,
            direction: RouteMapDirection::Incoming,
            map: RouteMapBuilder::new()
                .order(10)
                .allow()
                .match_neighbor(ext_net_idx)
                .set_local_pref(50)
                .build(),
        })?;

        // generate ebgp sessions to the two old neighbors
        for &ext in &[ext_lp100, ext_lp50] {
            let neighbor = self.graph.neighbors(ext).next().unwrap();
            let ext_net_idx = self.graph.node_weight(ext).unwrap().net_idx.unwrap();
            let int_net_idx = self.graph.node_weight(neighbor).unwrap().net_idx.unwrap();
            c1.add(BgpSession { source: ext_net_idx, target: int_net_idx, session_type: EBgp })?;
        }

        // generate the new session for the second configuration
        let mut c2 = c1.clone();
        for &ext in &[ext_new] {
            let neighbor = self.graph.neighbors(ext).next().unwrap();
            let ext_net_idx = self.graph.node_weight(ext).unwrap().net_idx.unwrap();
            let int_net_idx = self.graph.node_weight(neighbor).unwrap().net_idx.unwrap();
            c2.add(BgpSession { source: ext_net_idx, target: int_net_idx, session_type: EBgp })?;
        }

        // the hard policy will be empty!
        let policy = HardPolicy::globally(vec![]);

        let final_config = if reverse {
            net.set_config(&c2)?;
            c1
        } else {
            net.set_config(&c1)?;
            c2
        };

        net.advertise_external_route(
            self.graph.node_weight(ext_lp100).unwrap().net_idx.unwrap(),
            Prefix(0),
            vec![AsId(65101), AsId(65200)],
            None,
            None,
        )?;
        net.advertise_external_route(
            self.graph.node_weight(ext_lp50).unwrap().net_idx.unwrap(),
            Prefix(0),
            vec![AsId(65102), AsId(65200)],
            None,
            None,
        )?;
        net.advertise_external_route(
            self.graph.node_weight(ext_new).unwrap().net_idx.unwrap(),
            Prefix(0),
            vec![AsId(65103), AsId(65200)],
            None,
            None,
        )?;

        Ok((net, final_config, policy))
    }

    /// Returns a reference to the iBGP roots
    pub fn get_roots(&self) -> Vec<&str> {
        self.ibgp_roots
            .iter()
            .map(|idx| self.graph.node_weight(*idx).unwrap().name.as_str())
            .collect()
    }

    /// Randomize all link weights
    pub fn randomize_link_weights(&mut self, max: u32) -> &mut Self {
        info!("Randomize the link weights.");
        for edge_index in self.graph.edge_indices() {
            let edge_weight = self.graph.edge_weight_mut(edge_index).unwrap();
            let weight: u32 = (self.rng.next_u32() % max) + 1u32;
            *edge_weight = weight as LinkWeight;
        }
        self
    }

    /// Reset the seed to a known value
    pub fn set_seed(&mut self, seed: u64) -> &mut Self {
        self.rng = StdRng::seed_from_u64(seed);
        self
    }

    /// Forms an iBGP full mesh between all routers.
    pub fn ibgp_full_mesh(&mut self) -> &mut Self {
        self.ibgp_graph.clear_edges();
        // here, all nodes are roots.
        self.ibgp_roots = self
            .graph
            .node_indices()
            .into_iter()
            .filter(|x| !self.graph.node_weight(*x).unwrap().external)
            .collect();
        self
    }

    /// Forms an iBGP graph by choosing one route reflector in the network, where all other routers
    /// are connected to that router as client. Here, we choose the router having the most IGP
    /// connections to other internal routers.
    ///
    /// # Panics
    /// This function panics if there exists no internal router.
    pub fn ibgp_single_route_reflector_most_important(
        &mut self,
    ) -> Result<&mut Self, ZooTopologyError> {
        // choose the node with the most neighbors
        let best_root: NodeIdx = self
            .graph
            .node_indices()
            .into_iter()
            .filter(|x| !self.graph.node_weight(*x).unwrap().external)
            .max_by_key(|x| {
                self.graph
                    .neighbors(*x)
                    .filter(|n| !self.graph.node_weight(*n).unwrap().external)
                    .count()
            })
            .ok_or(ZooTopologyError::TooFewInternalRouters)?;

        Ok(self.ibgp_single_route_reflector(best_root))
    }

    /// Forms an iBGP graph by choosing one route reflector in the network, where all other routers
    /// are connected to that router as client. Here, we choose the route reflector at random.
    ///
    /// # Panics
    /// This function panics if there exists no internal router.
    pub fn ibgp_single_route_reflector_random(&mut self) -> Result<&mut Self, ZooTopologyError> {
        // choose the node with the most neighbors
        let mut nodes = self
            .graph
            .node_indices()
            .into_iter()
            .filter(|x| !self.graph.node_weight(*x).unwrap().external)
            .collect::<Vec<NodeIdx>>();
        nodes.shuffle(&mut self.rng);
        Ok(self.ibgp_single_route_reflector(
            *nodes.first().ok_or(ZooTopologyError::TooFewInternalRouters)?,
        ))
    }

    /// Forms an iBGP graph by choosing one route reflector in the network, where all other routers
    /// are connected to that router as client. Here, the router with the given name is selected.
    ///
    /// # Panics
    /// This function panics if there exists no internal router with the given name.
    pub fn ibgp_single_route_reflector_named(
        &mut self,
        root_name: &str,
    ) -> Result<&mut Self, ZooTopologyError> {
        // choose the node with the most neighbors
        let root = self
            .graph
            .node_indices()
            .into_iter()
            .find(|x| {
                let node_info = self.graph.node_weight(*x).unwrap();
                !node_info.external && node_info.name == root_name
            })
            .ok_or_else(|| ZooTopologyError::NameNotFound(root_name.to_string()))?;

        Ok(self.ibgp_single_route_reflector(root))
    }

    /// Form an iBGP graph by choosing two route reflectors in the network. All non-root routers
    /// are connected to both route reflectors, and the two route reflectors form a peering session.
    ///
    /// # Panics
    /// This funciton panics if there are less than 2 internal routers
    pub fn ibgp_two_route_reflectors_most_important(
        &mut self,
    ) -> Result<&mut Self, ZooTopologyError> {
        let mut internal_nodes = self
            .graph
            .node_indices()
            .into_iter()
            .filter(|x| !self.graph.node_weight(*x).unwrap().external)
            .collect::<Vec<_>>();
        internal_nodes.sort_by_key(|x| {
            self.graph
                .neighbors(*x)
                .filter(|n| !self.graph.node_weight(*n).unwrap().external)
                .count()
        });
        let mut internal_nodes_iter = internal_nodes.into_iter().rev();
        let roots = [
            internal_nodes_iter.next().ok_or(ZooTopologyError::TooFewInternalRouters)?,
            internal_nodes_iter.next().ok_or(ZooTopologyError::TooFewInternalRouters)?,
        ];

        Ok(self.ibgp_two_route_reflectors(roots))
    }

    /// Form an iBGP graph by choosing two route reflectors in the network. All non-root routers
    /// are connected to both route reflectors, and the two route reflectors form a peering session.
    /// One route reflector is chosen based on its importance, and the other is selected by name.
    ///
    /// # Panics
    /// This funciton panics if there exists less than 2 internal routers, and if the named router
    /// does not exist
    pub fn ibgp_two_route_reflectors_one_named_other_important(
        &mut self,
        root_name: &str,
    ) -> Result<&mut Self, ZooTopologyError> {
        let root_a = self
            .graph
            .node_indices()
            .into_iter()
            .find(|x| {
                let node_info = self.graph.node_weight(*x).unwrap();
                !node_info.external && node_info.name == root_name
            })
            .ok_or(ZooTopologyError::TooFewInternalRouters)?;

        let root_b = self
            .graph
            .node_indices()
            .into_iter()
            .filter(|x| !self.graph.node_weight(*x).unwrap().external)
            .filter(|x| *x != root_a)
            .max_by_key(|x| {
                self.graph
                    .neighbors(*x)
                    .filter(|n| !self.graph.node_weight(*n).unwrap().external)
                    .count()
            })
            .ok_or(ZooTopologyError::TooFewInternalRouters)?;

        let roots = [root_a, root_b];
        Ok(self.ibgp_two_route_reflectors(roots))
    }

    /// Form an iBGP graph by choosing two route reflectors in the network. All non-root routers
    /// are connected to both route reflectors, and the two route reflectors form a peering session.
    /// One route reflector is chosen randomly, and the other is selected by name.
    ///
    /// # Panics
    /// This funciton panics if there exists less than 2 internal routers, and if the named router
    /// does not exist
    pub fn ibgp_two_route_reflectors_one_named_other_random(
        &mut self,
        root_name: &str,
    ) -> Result<&mut Self, ZooTopologyError> {
        let root_a = self
            .graph
            .node_indices()
            .into_iter()
            .find(|x| {
                let node_info = self.graph.node_weight(*x).unwrap();
                !node_info.external && node_info.name == root_name
            })
            .ok_or(ZooTopologyError::TooFewInternalRouters)?;

        let mut nodes = self
            .graph
            .node_indices()
            .into_iter()
            .filter(|x| !self.graph.node_weight(*x).unwrap().external)
            .filter(|x| *x != root_a)
            .collect::<Vec<NodeIdx>>();
        nodes.shuffle(&mut self.rng);
        let root_b = nodes
            .into_iter()
            .next()
            .ok_or_else(|| ZooTopologyError::NameNotFound(root_name.to_string()))?;

        let roots = [root_a, root_b];
        Ok(self.ibgp_two_route_reflectors(roots))
    }

    /// Form an iBGP graph by choosing two route reflectors in the network. All non-root routers
    /// are connected to both route reflectors, and the two route reflectors form a peering session.
    ///
    /// # Panics
    /// This funciton panics if the two routers don't exist or are external routers
    pub fn ibgp_two_route_reflectors_named(
        &mut self,
        root_name_a: &str,
        root_name_b: &str,
    ) -> Result<&mut Self, ZooTopologyError> {
        let root_a = self
            .graph
            .node_indices()
            .into_iter()
            .find(|x| {
                let node_info = self.graph.node_weight(*x).unwrap();
                !node_info.external && node_info.name == root_name_a
            })
            .ok_or_else(|| ZooTopologyError::NameNotFound(root_name_a.to_string()))?;

        let root_b = self
            .graph
            .node_indices()
            .into_iter()
            .find(|x| {
                let node_info = self.graph.node_weight(*x).unwrap();
                !node_info.external && node_info.name == root_name_b
            })
            .ok_or_else(|| ZooTopologyError::NameNotFound(root_name_b.to_string()))?;

        let roots = [root_a, root_b];
        Ok(self.ibgp_two_route_reflectors(roots))
    }

    /// Prepares the ibgp graph such that it forms a spanning forest, originating from n root noes.
    /// This result will always be the same given the same seed
    ///
    /// # Panics
    /// This function panics if num_roots is larger than the number of internal routers in the
    /// network.
    pub fn ibgp_spanning_forest(&mut self, num_roots: usize) -> &mut Self {
        info!("Generate a spanning forest for the iBGP graph.");
        // clear everything that was before
        self.ibgp_roots.drain();
        self.ibgp_graph.clear_edges();

        // get a list of all internal nodes
        let mut nodes: Vec<NodeIdx> = self
            .graph
            .node_indices()
            .into_iter()
            .filter(|x| !self.graph.node_weight(*x).unwrap().external)
            .collect();
        // sort before shuffle, to guarantee that we always get the same result
        nodes.sort();
        // shuffle the vector and get the n roots
        nodes.shuffle(&mut self.rng);
        // select the roots
        for n in nodes.iter().take(num_roots) {
            self.ibgp_roots.insert(*n);
        }

        debug!(
            "Chosen roots: {:?}",
            self.ibgp_roots
                .iter()
                .map(|x| &self.graph.node_weight(*x).unwrap().name)
                .collect::<Vec<&String>>()
        );

        // setup the algorithm for building a spanning forest based around all roots
        let mut visited_nodes: HashSet<NodeIdx> = self.ibgp_roots.clone();
        let mut current_nodes: VecDeque<NodeIdx> = VecDeque::new();
        for n in nodes.iter().take(num_roots) {
            current_nodes.push_back(*n);
        }

        // prepare the current nodes
        while let Some(node) = current_nodes.pop_front() {
            let mut neighbors: Vec<NodeIdx> = self
                .graph
                .neighbors(node)
                .into_iter()
                .filter(|x| !self.graph.node_weight(*x).unwrap().external)
                .collect();
            neighbors.sort();
            neighbors.shuffle(&mut self.rng);
            for next in neighbors {
                if visited_nodes.insert(next) {
                    trace!(
                        "Adding link to spanning tree: {} -> {}",
                        self.graph.node_weight(node).unwrap().name,
                        self.graph.node_weight(next).unwrap().name
                    );
                    self.ibgp_graph.add_edge(node, next, ());
                    current_nodes.push_back(next);
                } // else, value was already present and we do nothing
            }
        }

        self
    }

    /// Prepares the network to be set up for a BGP acquisition. The following is done:
    /// 1. The netowrk is split into two connected parts. All links between the two components are
    ///    disabled. The two connected parts will both have at least one node connected to external
    ///    devices.
    /// 2. In one of the two components, the IGP weights will be scaled by the `igp_scale_factor`
    /// 3. Both components will select a route reflector, and all nodes in the component will have a
    ///    session to this route reflector.
    ///
    /// # Panics
    /// This function panics if the network cannot be split into two connected components. This can
    /// be the case if there exists only one router, that is connected to external devices.
    pub fn acquisition_before(
        &mut self,
        igp_scale_factor: f32,
    ) -> Result<&mut Self, ZooTopologyError> {
        // split the network into two components
        let mut component_a = Vec::new();
        let mut component_b = Vec::new();

        // chose two border routers as seeds to grow the two components
        let mut border_routers = self
            .graph
            .node_indices()
            .into_iter()
            .filter(|x| !self.graph.node_weight(*x).unwrap().external)
            .filter(|x| {
                self.graph
                    .neighbors(*x)
                    .filter(|n| self.graph.node_weight(*n).unwrap().external)
                    .count()
                    > 0
            });

        // choose two border routers as seeds
        component_a.push(border_routers.next().ok_or(ZooTopologyError::TooFewBorderRouters)?);
        component_b.push(border_routers.next().ok_or(ZooTopologyError::TooFewBorderRouters)?);

        let mut changed: bool = true;
        while changed {
            changed = false;
            // extend component a
            if let Some(next_a) = self.extend_node(&component_a, &component_b) {
                component_a.push(next_a);
                changed = true;
            }
            // extend component b
            if let Some(next_b) = self.extend_node(&component_b, &component_a) {
                component_b.push(next_b);
                changed = true;
            }
        }

        // network is now split into two parts. Go through and change the links
        for edge_idx in self.graph.edge_indices().collect::<Vec<_>>() {
            let (n1, n2) = self.graph.edge_endpoints(edge_idx).unwrap();
            let n1_member_a = if component_a.contains(&n1) {
                true
            } else if component_b.contains(&n1) {
                false
            } else {
                continue; // node is neither member of A or B
            };
            let n2_member_a = if component_a.contains(&n2) {
                true
            } else if component_b.contains(&n2) {
                false
            } else {
                continue; // node is neither member of A or B
            };
            match (n1_member_a, n2_member_a) {
                // if both are in a, nothing to do
                (true, true) => {}
                (false, false) => {
                    // we need to multiply the weight by the factor
                    let current_weight = self.graph.edge_weight_mut(edge_idx).unwrap();
                    *current_weight = (*current_weight * igp_scale_factor).round().max(1.0);
                }
                (false, true) | (true, false) => {
                    // we need to set the weight to infinity
                    *self.graph.edge_weight_mut(edge_idx).unwrap() = LinkWeight::INFINITY;
                }
            }
        }

        // get the two roots
        let root_a = component_a
            .iter()
            .cloned()
            .max_by_key(|x| {
                self.graph
                    .neighbors(*x)
                    .filter(|n| !self.graph.node_weight(*n).unwrap().external)
                    .count()
            })
            .expect("component_a cannot be empty!");
        let root_b = component_b
            .iter()
            .cloned()
            .max_by_key(|x| {
                self.graph
                    .neighbors(*x)
                    .filter(|n| !self.graph.node_weight(*n).unwrap().external)
                    .count()
            })
            .expect("component_b cannot be empty!");

        // clear the already existing information.
        self.ibgp_roots.drain();
        self.ibgp_graph.clear_edges();
        // setup the root node
        self.ibgp_roots.insert(root_a);
        self.ibgp_roots.insert(root_b);
        // create the edges
        for node_a in component_a.iter() {
            if *node_a == root_a {
                continue;
            }
            self.ibgp_graph.add_edge(root_a, *node_a, ());
        }
        for node_b in component_b.iter() {
            if *node_b == root_b {
                continue;
            }
            self.ibgp_graph.add_edge(root_b, *node_b, ());
        }

        self.create_ibgp_peers = false;
        self.disconnected = component_b.into_iter().collect();

        Ok(self)
    }

    /// Prepares the network to be set up after BGP acquisition. The following is done:
    /// 1. The two split network parts are reconnected, and their
    /// 2. In one of the two components, the IGP weights will be scaled by the inverse of `igp_scale_factor`
    /// 3. Both route reflectors will be connected.
    ///
    /// # Panics
    /// This function panics if the network cannot be split into two connected components. This can
    /// be the case if there exists only one router, that is connected to external devices.
    pub fn acquisition_after(&mut self, igp_scale_factor: f32, weight_max: u32) -> &mut Self {
        // split the network into two components
        let component_a = self
            .graph
            .node_indices()
            .filter(|idx| !self.disconnected.contains(idx))
            .filter(|idx| !self.graph.node_weight(*idx).unwrap().external)
            .collect::<Vec<_>>();
        let component_b = self.disconnected.iter().cloned().collect::<Vec<_>>();

        // network is now split into two parts. Go through and change the links
        for edge_idx in self.graph.edge_indices().collect::<Vec<_>>() {
            let (n1, n2) = self.graph.edge_endpoints(edge_idx).unwrap();
            let n1_member_a = if component_a.contains(&n1) {
                true
            } else if component_b.contains(&n1) {
                false
            } else {
                continue; // node is neither member of A or B
            };
            let n2_member_a = if component_a.contains(&n2) {
                true
            } else if component_b.contains(&n2) {
                false
            } else {
                continue; // node is neither member of A or B
            };
            match (n1_member_a, n2_member_a) {
                // if both are in a, nothing to do
                (true, true) => {}
                (false, false) => {
                    // we need to multiply the weight by the factor
                    let current_weight = self.graph.edge_weight_mut(edge_idx).unwrap();
                    *current_weight = (*current_weight / igp_scale_factor).round().max(1.0);
                }
                (false, true) | (true, false) => {
                    // we need to set the weight to infinity
                    let weight: u32 = (self.rng.next_u32() % weight_max) + 1u32;
                    *self.graph.edge_weight_mut(edge_idx).unwrap() = weight as LinkWeight;
                }
            }
        }

        self.create_ibgp_peers = true;
        self.disconnected.clear();

        self
    }

    /// Helper function to extend a component by one node, if possible.
    fn extend_node(&mut self, component: &[NodeIdx], other: &[NodeIdx]) -> Option<NodeIdx> {
        let mut choices = component
            .iter()
            .map(|idx| self.graph.neighbors(*idx))
            .flatten()
            .filter(|neighbor| !self.graph.node_weight(*neighbor).unwrap().external)
            .filter(|neighbor| !(component.contains(neighbor) || other.contains(neighbor)))
            .collect::<Vec<NodeIdx>>();
        choices.shuffle(&mut self.rng);
        choices.into_iter().next()
    }

    /// Generates a `netsim::network::Network` structure, and updates the internal datastructure
    /// to point to the correct indices of the network. This is required before you call the
    /// `get_config` method.
    pub fn get_net(&mut self) -> Network {
        info!("Generating the network");
        let mut net = Network::new();

        // generate the nodes
        for node in self.graph.node_indices() {
            let mut node_data = self.graph.node_weight_mut(node).unwrap();
            trace!("Adding node: {} with AS {}", node_data.name, node_data.as_id.0);
            let net_idx = if node_data.external {
                net.add_external_router(node_data.name.clone(), node_data.as_id)
            } else {
                net.add_router(node_data.name.clone())
            };
            node_data.net_idx = Some(net_idx);
        }

        // generate the links
        for edge_idx in self.graph.edge_indices() {
            let (src, dst) = self.graph.edge_endpoints(edge_idx).unwrap();
            trace!(
                "Adding link: {} -> {}",
                self.graph.node_weight(src).unwrap().name,
                self.graph.node_weight(dst).unwrap().name
            );
            let src_net_idx = self.graph.node_weight(src).unwrap().net_idx.unwrap();
            let dst_net_idx = self.graph.node_weight(dst).unwrap().net_idx.unwrap();
            net.add_link(src_net_idx, dst_net_idx);
        }

        net
    }

    /// # Advertise prefixes
    /// This function will make sure that external routers advertise some prefixes in the following
    /// way:
    ///
    /// For each prefix and for each external router, determine (by using randomness), if the route
    /// should be advertised by by this external router, based on the probability given as argument.
    pub fn advertise_prefixes(
        &mut self,
        net: &mut Network,
        num_prefixes: usize,
        probability: f64,
    ) -> Result<(), NetworkError> {
        info!("Advertise {} prefixes in the network", num_prefixes);
        let mut external_nodes: Vec<NodeIdx> = self
            .graph
            .node_indices()
            .into_iter()
            .filter(|x| self.graph.node_weight(*x).unwrap().external)
            .collect();
        // sort before shuffle, to guarantee that we always get the same result
        external_nodes.sort();

        let mut prefixes: Vec<(Prefix, AsId)> = Vec::with_capacity(num_prefixes);
        for i in 0..num_prefixes {
            prefixes.push((Prefix(i as u32), AsId(65300 + i as u32)));
        }

        let mut component_known_prefixes = [HashSet::new(), HashSet::new()];

        for node in external_nodes.iter().cloned() {
            let node_as_id = self.graph.node_weight(node).unwrap().as_id;
            for (prefix, origin_as) in prefixes.iter() {
                // check the probability
                let choice: f64 = self.rng.gen();
                if choice <= probability {
                    trace!(
                        "{} advertises {}",
                        self.graph.node_weight(node).unwrap().name,
                        prefix.0
                    );
                    net.advertise_external_route(
                        node,
                        *prefix,
                        vec![node_as_id, *origin_as],
                        None,
                        None,
                    )?;
                    match self.graph.neighbors(node).next() {
                        Some(neighbor) => {
                            if self.disconnected.contains(&neighbor) {
                                component_known_prefixes[1].insert(*prefix);
                            } else {
                                component_known_prefixes[0].insert(*prefix);
                            }
                        }
                        None => {}
                    }
                }
            }
        }

        // if we are disconnected, we need to make sure that both components know the same prefixes
        if !self.disconnected.is_empty() {
            // prepare the must known prefixes and the lookup for the AS id
            let must_known_prefixes: HashSet<Prefix> =
                prefixes.iter().map(|(p, _)| p).cloned().collect();
            let prefix_as: HashMap<Prefix, AsId> = prefixes.iter().cloned().collect();

            // get the set of all external routers in the components
            let mut component_external_routers = [
                self.graph
                    .node_indices()
                    .filter(|idx| !self.disconnected.contains(idx))
                    .map(|idx| self.graph.neighbors(idx))
                    .flatten()
                    .filter(|idx| self.graph.node_weight(*idx).unwrap().external)
                    .collect::<Vec<_>>(),
                self.graph
                    .node_indices()
                    .filter(|idx| self.disconnected.contains(idx))
                    .map(|idx| self.graph.neighbors(idx))
                    .flatten()
                    .filter(|idx| self.graph.node_weight(*idx).unwrap().external)
                    .collect::<Vec<_>>(),
            ];
            // sort and dedup them both
            component_external_routers[0].sort();
            component_external_routers[1].sort();
            component_external_routers[0].dedup();
            component_external_routers[1].dedup();

            // go through both components
            for (known_prefixes, external_routers) in
                component_known_prefixes.iter().zip(component_external_routers.iter())
            {
                // compute the difference between the components
                let mut differences: Vec<Prefix> =
                    must_known_prefixes.difference(&known_prefixes).cloned().collect();
                differences.sort_by_key(|x| x.0);

                // for each of the missing prefixes, we need to advertise at a single router
                for prefix in differences {
                    let origin_as = prefix_as.get(&prefix).expect("must be known at this point");
                    // choose a random router
                    let node = external_routers
                        .get(self.rng.gen_range(0, external_routers.len()))
                        .unwrap();
                    let node_as_id = self.graph.node_weight(*node).unwrap().as_id;

                    // advertise the prefix
                    trace!(
                        "{} advertises {}",
                        self.graph.node_weight(*node).unwrap().name,
                        prefix.0
                    );
                    net.advertise_external_route(
                        *node,
                        prefix,
                        vec![node_as_id, *origin_as],
                        None,
                        None,
                    )?;
                }
            }
        }

        Ok(())
    }

    /// Returns the current configuration based on the already prepared data.
    ///
    /// # Panics
    /// This function panics if the network was not already generated, and the node indexes are not
    /// yet present!
    pub fn get_config(&self) -> Result<Config, ZooTopologyError> {
        self.prepare_config(true)
    }

    /// Internal function to prepare the config, with some flags to describe how the config should
    /// be generated.
    fn prepare_config(&self, generate_ebgp: bool) -> Result<Config, ZooTopologyError> {
        info!("Generate configuration.");
        let mut c = Config::new();

        // first, add all igp link weights
        for edge_idx in self.graph.edge_indices() {
            let (src, dst) = self.graph.edge_endpoints(edge_idx).unwrap();
            let src_net_idx = self.graph.node_weight(src).unwrap().net_idx.unwrap();
            let dst_net_idx = self.graph.node_weight(dst).unwrap().net_idx.unwrap();
            let weight = *self.graph.edge_weight(edge_idx).unwrap();
            trace!(
                "Configure link {} <--> {}, weight: {:.0}",
                self.graph.node_weight(src).unwrap().name,
                self.graph.node_weight(dst).unwrap().name,
                weight
            );

            debug!(
                "Configure link {} <--> {}, weight: {:.0}",
                self.graph.node_weight(src).unwrap().name,
                self.graph.node_weight(dst).unwrap().name,
                weight
            );
            c.add(IgpLinkWeight { source: src_net_idx, target: dst_net_idx, weight })
                .map_err(|_| ZooTopologyError::MultipleLinkWeights)?;
            c.add(IgpLinkWeight { target: src_net_idx, source: dst_net_idx, weight })
                .map_err(|_| ZooTopologyError::MultipleLinkWeights)?;
        }

        // then, add all ebgp sessions
        if generate_ebgp {
            for external_router in self
                .graph
                .node_indices()
                .into_iter()
                .filter(|x| self.graph.node_weight(*x).unwrap().external)
            {
                for neighbor in self.graph.neighbors(external_router) {
                    let ext_net_idx =
                        self.graph.node_weight(external_router).unwrap().net_idx.unwrap();
                    let int_net_idx = self.graph.node_weight(neighbor).unwrap().net_idx.unwrap();
                    trace!(
                        "Add eBGP session: {} --> {}",
                        self.graph.node_weight(int_net_idx).unwrap().name,
                        self.graph.node_weight(ext_net_idx).unwrap().name,
                    );
                    match c.add(BgpSession {
                        source: ext_net_idx,
                        target: int_net_idx,
                        session_type: EBgp,
                    }) {
                        Ok(()) => {}
                        Err(_) => return Err(ZooTopologyError::MultipleBgpSessions),
                    }
                }
            }
        }

        // then, add the ibgp full mesh between the root nodes. But only, if it is enabled
        if self.create_ibgp_peers {
            let roots: Vec<NodeIdx> = self.ibgp_roots.iter().cloned().collect();
            for ia in 0..roots.len() {
                for ib in (ia + 1)..roots.len() {
                    let (src, dst) = (roots[ia], roots[ib]);
                    let src_net_idx = self.graph.node_weight(src).unwrap().net_idx.unwrap();
                    let dst_net_idx = self.graph.node_weight(dst).unwrap().net_idx.unwrap();
                    trace!(
                        "Add iBGP peer session: {} --> {}",
                        self.graph.node_weight(src_net_idx).unwrap().name,
                        self.graph.node_weight(dst_net_idx).unwrap().name,
                    );
                    c.add(BgpSession {
                        source: src_net_idx,
                        target: dst_net_idx,
                        session_type: IBgpPeer,
                    })
                    .unwrap();
                }
            }
        }

        // finally, add all iBGP client -> RR sessions
        for edge_idx in self.ibgp_graph.edge_indices() {
            let (src, dst) = self.ibgp_graph.edge_endpoints(edge_idx).unwrap();
            let src_net_idx = self.graph.node_weight(src).unwrap().net_idx.unwrap();
            let dst_net_idx = self.graph.node_weight(dst).unwrap().net_idx.unwrap();
            trace!(
                "Add iBGP RR-client session: {} --> {}",
                self.graph.node_weight(src_net_idx).unwrap().name,
                self.graph.node_weight(dst_net_idx).unwrap().name,
            );
            c.add(BgpSession {
                source: src_net_idx,
                target: dst_net_idx,
                session_type: IBgpClient,
            })
            .unwrap();
        }

        Ok(c)
    }

    /// Generates a iBGP route reflector topology, where the root is the only route reflector, and
    /// all other internal routers are connected to it.
    fn ibgp_single_route_reflector(&mut self, root: NodeIdx) -> &mut Self {
        // clear the already existing information.
        self.ibgp_roots.drain();
        self.ibgp_graph.clear_edges();

        // setup the root node
        self.ibgp_roots.insert(root);

        // iterate over all internal routers, except the root
        for node in self
            .graph
            .node_indices()
            .into_iter()
            .filter(|x| !self.graph.node_weight(*x).unwrap().external)
            .filter(|x| x != &root)
            // we need to collect because we already borrow self inside the filter.
            .collect::<Vec<_>>()
        {
            self.ibgp_graph.add_edge(root, node, ());
        }

        self
    }

    /// Generates a iBGP route reflector topology, where the two root are the only route reflectors,
    /// and all other internal routers are connected to both of them. The two route reflectors have
    /// a peer session between them.
    fn ibgp_two_route_reflectors(&mut self, root: [NodeIdx; 2]) -> &mut Self {
        // clear the already existing information.
        self.ibgp_roots.drain();
        self.ibgp_graph.clear_edges();

        // setup the root node
        self.ibgp_roots.insert(root[0]);
        self.ibgp_roots.insert(root[1]);

        // iterate over all internal routers, except the root
        for node in self
            .graph
            .node_indices()
            .into_iter()
            .filter(|x| !self.graph.node_weight(*x).unwrap().external)
            .filter(|x| x != &root[0] && x != &root[1])
            // we need to collect because we already borrow self inside the filter.
            .collect::<Vec<_>>()
        {
            self.ibgp_graph.add_edge(root[0], node, ());
            self.ibgp_graph.add_edge(root[1], node, ());
        }
        self
    }

    /// Generates a iBGP route reflector topology, by selecting n routers as route reflectors,
    /// connected in a full mesh, and every other router to choose the closest reflector.
    fn ibgp_general_route_reflectors(
        &mut self,
        num_roots: usize,
    ) -> Result<&mut Self, ZooTopologyError> {
        // clear the already existing information.
        self.ibgp_roots.drain();
        self.ibgp_graph.clear_edges();

        // choose the most important n route reflectors
        let mut internal_nodes = self
            .graph
            .node_indices()
            .into_iter()
            .filter(|x| !self.graph.node_weight(*x).unwrap().external)
            .collect::<Vec<_>>();
        internal_nodes.sort_by_key(|x| {
            self.graph
                .neighbors(*x)
                .filter(|n| !self.graph.node_weight(*n).unwrap().external)
                .count()
        });
        self.ibgp_roots = internal_nodes.into_iter().rev().take(num_roots).collect();

        for node in self
            .graph
            .node_indices()
            .into_iter()
            .filter(|x| !self.graph.node_weight(*x).unwrap().external)
            .filter(|x| !self.ibgp_roots.contains(x))
            // we need to collect because we already borrow self inside the filter.
            .collect::<Vec<_>>()
        {
            let closest_root = self.find_closest_root(node)?;
            self.ibgp_graph.add_edge(closest_root, node, ());
        }

        Ok(self)
    }

    /// helper function to find the closest root in BFS manner.
    fn find_closest_root(&self, node: NodeIndex<u32>) -> Result<NodeIndex<u32>, ZooTopologyError> {
        let mut visited = HashSet::new();
        let mut queue = VecDeque::new();

        queue.push_back(node);
        while !queue.is_empty() {
            let node = queue.pop_front().unwrap();
            for neighbor in self.graph.neighbors_undirected(node) {
                if self.ibgp_roots.contains(&neighbor) {
                    return Ok(neighbor);
                }
                if !visited.contains(&neighbor) {
                    visited.insert(neighbor);
                    queue.push_back(neighbor);
                }
            }
        }

        Err(ZooTopologyError::NoClosestRootFound)
    }
}

/// Scenario to apply to a topology in TopologyZoo
#[derive(Debug, Clone)]
pub enum Scenario {
    /// Scenario, where we start with a iBGP full mesh, and end up with a topology, where one single
    /// router is elected as a Route Reflectors, and all others pair with that router.
    FullMesh2RouteReflector,
    /// Scenario, where we start with a topology, where one single router is elected as a Route
    /// Reflectors, and all others pair with that router, and we end up wiht an iBGP full mesh.
    RouteReflector2FullMesh,
    /// Scenario, where every IGP weight is doubled
    DoubleIgpWeight,
    /// Scenario, where every IGP weight is halved
    HalveIgpWeight,
    /// Scenario, where we start with a single Route-Reflector, to which all other routers pair, and
    /// end with a second Route-Reflector as a backup, where all other routers have a session to
    /// both reflectors, and the two reflectors are connected with a peer.
    IntroduceSecondRouteReflector,
    /// Scenario, where we start with a second Route-Reflector as a backup, where all other routers
    /// have a session to both reflectors, and the two reflectors are connected with a peer, and end
    /// with a single Route-Reflector, to which all other routers pair.
    RemoveSecondRouteReflector,
    /// Scenario, where we start with two different connected components, both having connection to
    /// the outside world, and we merge them by adding the links in between.
    NetworkAcquisition,
    /// Reverse scenario of the Network Acquisition
    NetworkSplit,
    /// Shutdown a router by setting all link weights around a specific router to infinity
    DisconnectRouter,
    /// Introduce a new router by starting with infinite weight of all links around a specific
    /// router, and setting them to something reasonable.
    ConnectRouter,
    /// Scenario where every local-pref configuration is doulbed
    DoubleLocalPref,
    /// Scenario where every local-pref is halved
    HalveLocalPref,
    /// Test scenario for verifying transient state conditions. This scenario contains only a single
    /// modifier, which adds an eBGP session.
    VerifyTransientCondition,
    /// Test scenario for verifying transient state conditions. This scenario contains only a single
    /// modifier, which adds an eBGP session.
    VerifyTransientConditionReverse,
    /// Zibin: MltiRRCase
    MultiRR,
}

impl Scenario {
    fn is_inverse(&self) -> bool {
        match self {
            Scenario::FullMesh2RouteReflector
            | Scenario::MultiRR
            | Scenario::DoubleIgpWeight
            | Scenario::IntroduceSecondRouteReflector
            | Scenario::NetworkAcquisition
            | Scenario::DisconnectRouter
            | Scenario::DoubleLocalPref
            | Scenario::VerifyTransientCondition => false,
            Scenario::RouteReflector2FullMesh
            | Scenario::HalveIgpWeight
            | Scenario::RemoveSecondRouteReflector
            | Scenario::NetworkSplit
            | Scenario::ConnectRouter
            | Scenario::HalveLocalPref
            | Scenario::VerifyTransientConditionReverse => true,
        }
    }
}

/// Node Data of ZooTopology graph
#[derive(Debug, Clone)]
pub struct NodeData {
    /// Name of the node
    pub name: String,
    /// Wether the node is an external router or not
    pub external: bool,
    /// As Id
    pub as_id: AsId,
    /// The index of the node in `netsim::network::Network`
    pub net_idx: Option<RouterId>,
    /// unique id
    pub uid: Option<usize>,
}

#[cfg(test)]
mod test {
    use super::*;
    #[test]
    fn link_weight() {
        let gml_filename: String = format!("{}/test_files/switch.gml", env!("CARGO_MANIFEST_DIR"));
        let mut t = ZooTopology::new(gml_filename, 42).unwrap();

        // test before
        for edge_idx in t.graph.edge_indices() {
            let weight = t.graph.edge_weight(edge_idx).unwrap();
            let weight = weight.round() as u32;
            assert_eq!(weight, 1);
        }

        // randomize link weights
        let max_val = 100;
        t.randomize_link_weights(max_val);

        // test after
        for edge_idx in t.graph.edge_indices() {
            let weight = t.graph.edge_weight(edge_idx).unwrap();
            let weight = weight.round() as u32;
            assert!(weight >= 1);
            assert!(weight <= 100);
        }
    }

    #[test]
    fn ibgp_spanning_forest() {
        let gml_filename: String = format!("{}/test_files/switch.gml", env!("CARGO_MANIFEST_DIR"));
        let mut t = ZooTopology::new(gml_filename, 42).unwrap();

        // check that the ibgp graph has the same nodes as graph, but has absolutely no edges
        assert_eq!(t.ibgp_graph.node_count(), t.graph.node_count());
        assert_eq!(t.ibgp_graph.edge_count(), 0);

        t.ibgp_spanning_forest(4);

        assert_eq!(t.ibgp_roots.len(), 4);

        // check that everything is connected properly
        for node_idx in t.ibgp_graph.node_indices() {
            let node_data = t.graph.node_weight(node_idx).unwrap();
            if node_data.external {
                // assert that the node has no neighbor in the ibgp graph
                assert_eq!(t.ibgp_graph.neighbors_undirected(node_idx).next(), None);
            } else {
                // assert that either it has a single incoming edge, or is root
                if t.ibgp_roots.contains(&node_idx) {
                    // can have no incoming edge
                    assert_eq!(
                        t.ibgp_graph.neighbors_directed(node_idx, Direction::Incoming).next(),
                        None
                    );
                } else {
                    // can have only one incoming edge
                    let mut parents_iter =
                        t.ibgp_graph.neighbors_directed(node_idx, Direction::Incoming);
                    assert!(parents_iter.next().is_some());
                    assert!(parents_iter.next().is_none());
                }
            }
        }
    }

    #[test]
    fn ibgp_full_mesh() {
        let gml_filename: String = format!("{}/test_files/switch.gml", env!("CARGO_MANIFEST_DIR"));
        let mut t = ZooTopology::new(gml_filename, 42).unwrap();

        // check that the ibgp graph has the same nodes as graph, but has absolutely no edges
        assert_eq!(t.ibgp_graph.node_count(), t.graph.node_count());
        assert_eq!(t.ibgp_graph.edge_count(), 0);

        t.ibgp_full_mesh();

        let num_internal_nodes = t
            .graph
            .node_indices()
            .into_iter()
            .filter(|x| !t.graph.node_weight(*x).unwrap().external)
            .count();

        assert_eq!(t.ibgp_roots.len(), num_internal_nodes);
        assert_eq!(t.ibgp_graph.edge_count(), 0);
    }

    #[test]
    fn ibgp_single_route_reflector() {
        let gml_filename: String = format!("{}/test_files/switch.gml", env!("CARGO_MANIFEST_DIR"));
        let mut t = ZooTopology::new(gml_filename, 42).unwrap();

        // check that the ibgp graph has the same nodes as graph, but has absolutely no edges
        assert_eq!(t.ibgp_graph.node_count(), t.graph.node_count());
        assert_eq!(t.ibgp_graph.edge_count(), 0);

        t.ibgp_single_route_reflector_named("Bern").unwrap();

        let num_internal_nodes = t
            .graph
            .node_indices()
            .into_iter()
            .filter(|x| !t.graph.node_weight(*x).unwrap().external)
            .count();

        assert_eq!(t.ibgp_roots.len(), 1);
        assert_eq!(t.ibgp_graph.edge_count(), num_internal_nodes - 1);

        let root = t.ibgp_roots.iter().cloned().next().unwrap();

        // check that everything is connected properly
        for node_idx in t.ibgp_graph.node_indices() {
            let node_data = t.graph.node_weight(node_idx).unwrap();
            if node_data.external {
                // assert that the node has no neighbor in the ibgp graph
                assert_eq!(t.ibgp_graph.neighbors_undirected(node_idx).next(), None);
            } else {
                // assert that either it has a single incoming edge, or is root
                if t.ibgp_roots.contains(&node_idx) {
                    // can have no incoming edge
                    assert_eq!(
                        t.ibgp_graph.neighbors_directed(node_idx, Direction::Incoming).next(),
                        None
                    );
                    // check that its name is Bern
                    assert_eq!(t.graph.node_weight(node_idx).unwrap().name, "Bern");
                } else {
                    // this route needs to have exactly one edge to the root
                    let mut parents_iter =
                        t.ibgp_graph.neighbors_directed(node_idx, Direction::Incoming);
                    assert_eq!(parents_iter.next(), Some(root));
                    assert!(parents_iter.next().is_none());
                }
            }
        }
    }

    #[test]
    fn advertise_prefix() {
        let gml_filename: String = format!("{}/test_files/switch.gml", env!("CARGO_MANIFEST_DIR"));
        let mut t = ZooTopology::new(gml_filename, 42).unwrap();
        t.ibgp_spanning_forest(4);

        // generate the network
        let mut net = t.get_net();
        net.set_config(&t.get_config().unwrap()).unwrap();
        t.advertise_prefixes(&mut net, 100, 1.0).unwrap();
        assert_eq!(net.get_known_prefixes().len(), 100);

        // check if all nodes know all 100 prefixes
        for router_id in net.get_routers() {
            for prefix in net.get_known_prefixes() {
                assert!(net.get_route(router_id, *prefix).is_ok())
            }
        }
    }
}
