<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `Network` struct in crate `snowcap`."><meta name="keywords" content="rust, rustlang, rust-lang, Network"><title>snowcap::netsim::Network - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"                  integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"    integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "\\(", right: "\\)", display: false},
                {left: "$", right: "$", display: false},
                {left: "\\[", right: "\\]", display: true}
            ]
        });
    });
</script>

<style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../snowcap/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><p class="location">Struct Network</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#implementations">Methods</a><div class="sidebar-links"><a href="#method.add_external_router">add_external_router</a><a href="#method.add_link">add_link</a><a href="#method.add_router">add_router</a><a href="#method.advertise_external_route">advertise_external_route</a><a href="#method.apply_modifier">apply_modifier</a><a href="#method.apply_modifier_check_transient">apply_modifier_check_transient</a><a href="#method.apply_patch">apply_patch</a><a href="#method.clear_undo_stack">clear_undo_stack</a><a href="#method.current_config">current_config</a><a href="#method.get_device">get_device</a><a href="#method.get_external_routers">get_external_routers</a><a href="#method.get_forwarding_state">get_forwarding_state</a><a href="#method.get_known_prefixes">get_known_prefixes</a><a href="#method.get_route">get_route</a><a href="#method.get_router_id">get_router_id</a><a href="#method.get_router_name">get_router_name</a><a href="#method.get_routers">get_routers</a><a href="#method.get_topology">get_topology</a><a href="#method.links_symmetric">links_symmetric</a><a href="#method.new">new</a><a href="#method.num_devices">num_devices</a><a href="#method.num_msg_exchanged">num_msg_exchanged</a><a href="#method.print_igp_fw_table">print_igp_fw_table</a><a href="#method.print_route">print_route</a><a href="#method.retract_external_route">retract_external_route</a><a href="#method.set_config">set_config</a><a href="#method.set_msg_limit">set_msg_limit</a><a href="#method.undo_action">undo_action</a><a href="#method.weak_eq">weak_eq</a></div><a class="sidebar-title" href="#trait-implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-Debug">Debug</a><a href="#impl-Default">Default</a><a href="#impl-PartialEq%3CNetwork%3E">PartialEq&lt;Network&gt;</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-RefUnwindSafe">RefUnwindSafe</a><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">UnwindSafe</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a><a href="#impl-VZip%3CV%3E">VZip&lt;V&gt;</a></div></div><p class="location"><a href="../index.html">snowcap</a>::<wbr><a href="index.html">netsim</a></p><div id="sidebar-vars" data-name="Network" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Struct <a href="../index.html">snowcap</a>::<wbr><a href="index.html">netsim</a>::<wbr><a class="struct" href="">Network</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#140-151" title="goto source code">[src]</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class="rust struct">pub struct Network { /* fields omitted */ }</pre></div><div class="docblock"><h1 id="network-struct" class="section-header"><a href="#network-struct">Network struct</a></h1>
<p>The struct contains all information about the underlying physical network (Links), a manages
all (both internal and external) routers, and handles all events between them. Configuration is
applied on the network itself, treated as network-wide configuration.</p>
<h2 id="undo-funcitonality" class="section-header"><a href="#undo-funcitonality">Undo Funcitonality</a></h2>
<p>The Undo funcitonality is implemented by two interacting parts. First, the network keeps track
of all past events (in the <code>event_history</code>). Second, every network device keeps a local stack,
in which all information is present to undo an event.</p>
<p>The network is responsible for calling undo on the correct network device, since the network
device does not check if the event matches the one which caused the modifications in the first
place. This is trivial for all BGP messages exchanged, but not for configuration modifications
and other user interactions with the network. For changes in external advertised routes, we need
not to do something, except changing the external routers. For the configuraiton changes, we
reverse the modifier (delete becomes insert, and modify swaps the old and the new expression),
and call the same function as appyling a normal modifier, but set the <code>undo</code> flag to true. Then,
instead of updating the bgp tables on the routers, the function will call <code>undo_last_event</code> on
the same router as the action before has updated the BGP tables.</p>
<p>Along with each event, the network stores the parent event ID in the <code>event history</code>. This
allows us to recreate the exact event queue when undoing a single event. When we undo an event,
we check the queue if any of them have as parent ID the ID of the event that was restored. If
so, they will be removed. When undoing an entire action (like applying a config modification),
we do not keep track of the queue, but just delete it in the end, since we require the queue to
be empty when applying a new modifier.</p>
<h2 id="transient-state" class="section-header"><a href="#transient-state">Transient State</a></h2>
<p><strong>NOTE</strong> This part of the code is currently commented out due to legacy hard policy use.
Additionally, we have figured out that for some networks, this approach may lead to an infinite
loop of messages. This approach does not work, and therefore, it should not be used.</p>
<p>By calling <code>apply_modifier_check_constraint</code>, we explore the entire space of event orderings.
This is done by checking if two events do commute or not. The exact algorithm works as follows:</p>
<ol>
<li>
<p>First, we apply the modifier as normal, and check that it does converge. Then, we compute the
set of prefixes, which were affected by the modification. We then undo all events as before,
and reapply the modifier without executing the queue.</p>
</li>
<li>
<p>The following sequence is then repeated for each prefix that affected by the modification:</p>
<ol>
<li>We create a stack that keeps track of all event reordering at every step, that still needs
to be explored.</li>
<li>Then, we continue as follows:
<ol>
<li>If the current branch is not yet entered, we take the next event from the queue, and
build a set of non-commuting events from the events that are still inside the queue
(see <a href="#commutativity">Commutativity</a>). If the event does not
correspond to the chosen prefix, we ignore all non-commuting events and use an empty
set. Then, We push this set onto the stack.</li>
<li>If the current branch is already entered, take out one event form the stack and
continue with this event.</li>
</ol>
</li>
<li>Next, we execute the the chosen event (from 2.2.1 or 2.2.2). If the event changed the
forwarding state of the network, we check the hard hard_policy (but only for the chosen
prefix). If they fail, we return the from the procedure with an error.</li>
<li>Finally, there are three different ways in which we continue:
<ol>
<li>If the queue is not empty, we continue with step 2.2.1.</li>
<li>If the queue is empty, and there are no branches left to explore, we call this prefix
ok and continue with the next prefix on step 2.</li>
<li>If the queue is empty, and there are still branches left to explore, we undo all events
on the network until we reach the most recent point where there are still branches to
explore. At the same time, we pop the stack to keep it consistent with the network
state. Then, continue with step 2.2.2.</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="notes-and-details" class="section-header"><a href="#notes-and-details">Notes and Details</a></h3>
<ul>
<li>
<p><em>TCP Streams</em>: BGP is a Distance-Vector protocol that exchanges messages via TCP. This means,
that two BGP routers with an active BGP session also have an active TCP session open. Since
TCP is a reliable transport protocol, we can be sure that all BGP messages are received by the
destination router, and that the messages of one BGP session are always received in the same
order as they are sent. This means, that two BGP messages that both have the same source and
destination cannot be reordere (at least if they are caused at different time instances).
Hence, in step 2.2.1, two things need to happen:</p>
<ol>
<li>When taking the next event from the queue, we check if the TCP transmission order is
validated. If so, then choose the event which must be handled first by the destination
router.</li>
<li>When preparing the set of events that may not commute with the cosen one, we need also to
consider the event ordering. We are not allowed to add events to the set if it does not
comply with the TCP order. This is achieved by checking every event if it must be freezed.</li>
</ol>
<p>However, something is very important: while computing the non-commutive events for event
$e_A$, and when event $e_B$ is freezed due to TCP ordering with event $e_C$, then events $e_A$
and $C$ do not commute, since applying $e_C$ might cause $e_B$ to be applied, which in terms
might commute with $e_A$.</p>
</li>
<li>
<p><em>Decoupling Prefixes</em> In step 2 of the algorithm, we iterate over all prefixes that are
updated during convergence. First, we are allowed to do this, because all events talking about
two different prefixes do commute. Also, it reduces the complexity of the algorithm
dramatically. Assume events $e_{11}$, $e_{12}$ and $e_{13}$ are for prefix 1 and all are not
commutative, and $e_{21}$, $e_{22}$, and $e_{23}$ are for prefix 2, which also do not commute.
When not decoupling the prefixes, we need to check $3! \cdot 3! = 36$ orderings. However, when
decoupling the two prefixes, we only need to check $3! + 3! = 12$ orderings.</p>
</li>
</ul>
</div><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><h3 id="impl" class="impl"><code class="in-band">impl <a class="struct" href="../../snowcap/netsim/struct.Network.html" title="struct snowcap::netsim::Network">Network</a></code><a href="#impl" class="anchor"></a><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#178-1721" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.new" class="method"><code>pub fn <a href="#method.new" class="fnname">new</a>() -&gt; Self</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#180-193" title="goto source code">[src]</a></h4><div class="docblock"><p>Generate an empty Network</p>
</div><h4 id="method.add_router" class="method"><code>pub fn <a href="#method.add_router" class="fnname">add_router</a>&lt;S:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;&gt;(&amp;mut self, name: S) -&gt; <a class="type" href="../../snowcap/netsim/type.RouterId.html" title="type snowcap::netsim::RouterId">RouterId</a></code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#198-203" title="goto source code">[src]</a></h4><div class="docblock"><p>Add a new router to the topology. Note, that the AS id is always set to <code>AsId(65001)</code>. This
function returns the ID of the router, which can be used to reference it while confiugring
the network.</p>
</div><h4 id="method.add_external_router" class="method"><code>pub fn <a href="#method.add_external_router" class="fnname">add_external_router</a>&lt;S:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;name: S, <br>&nbsp;&nbsp;&nbsp;&nbsp;as_id: <a class="struct" href="../../snowcap/netsim/struct.AsId.html" title="struct snowcap::netsim::AsId">AsId</a><br>) -&gt; <a class="type" href="../../snowcap/netsim/type.RouterId.html" title="type snowcap::netsim::RouterId">RouterId</a></code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#208-213" title="goto source code">[src]</a></h4><div class="docblock"><p>Add a new external router to the topology. An external router does not process any BGP
messages, it just advertises routes from outside of the network. This function returns
the ID of the router, which can be used to reference it while configuring the network.</p>
</div><h4 id="method.add_link" class="method"><code>pub fn <a href="#method.add_link" class="fnname">add_link</a>(&amp;mut self, source: <a class="type" href="../../snowcap/netsim/type.RouterId.html" title="type snowcap::netsim::RouterId">RouterId</a>, target: <a class="type" href="../../snowcap/netsim/type.RouterId.html" title="type snowcap::netsim::RouterId">RouterId</a>)</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#239-243" title="goto source code">[src]</a></h4><div class="docblock"><p>This function creates an link in the network The link will have infinite weight for both
directions. The network needs to be configured such that routers can use the link, since
a link with infinte weight is treated as not connected.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">net</span> <span class="op">=</span> <span class="ident">Network</span>::<span class="ident">new</span>();
<span class="kw">let</span> <span class="ident">r1</span> <span class="op">=</span> <span class="ident">net</span>.<span class="ident">add_router</span>(<span class="string">&quot;r1&quot;</span>);
<span class="kw">let</span> <span class="ident">r2</span> <span class="op">=</span> <span class="ident">net</span>.<span class="ident">add_router</span>(<span class="string">&quot;r2&quot;</span>);
<span class="ident">net</span>.<span class="ident">add_link</span>(<span class="ident">r1</span>, <span class="ident">r2</span>);
<span class="ident">net</span>.<span class="ident">apply_modifier</span>(<span class="kw-2">&amp;</span><span class="ident">ConfigModifier</span>::<span class="ident">Insert</span>(<span class="ident">ConfigExpr</span>::<span class="ident">IgpLinkWeight</span> {
    <span class="ident">source</span>: <span class="ident">r1</span>,
    <span class="ident">target</span>: <span class="ident">r2</span>,
    <span class="ident">weight</span>: <span class="number">5.0</span>,
}))<span class="question-mark">?</span>;
<span class="ident">net</span>.<span class="ident">apply_modifier</span>(<span class="kw-2">&amp;</span><span class="ident">ConfigModifier</span>::<span class="ident">Insert</span>(<span class="ident">ConfigExpr</span>::<span class="ident">IgpLinkWeight</span> {
    <span class="ident">source</span>: <span class="ident">r2</span>,
    <span class="ident">target</span>: <span class="ident">r1</span>,
    <span class="ident">weight</span>: <span class="number">4.0</span>,
}))<span class="question-mark">?</span>;</pre></div>
</div><h4 id="method.set_config" class="method"><code>pub fn <a href="#method.set_config" class="fnname">set_config</a>(&amp;mut self, config: &amp;<a class="struct" href="../../snowcap/netsim/config/struct.Config.html" title="struct snowcap::netsim::config::Config">Config</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="enum" href="../../snowcap/netsim/enum.NetworkError.html" title="enum snowcap::netsim::NetworkError">NetworkError</a>&gt;</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#250-253" title="goto source code">[src]</a></h4><div class="docblock"><p>Set the provided network-wide configuration. The network first computes the patch from the
current configuration to the next one, and applies the patch. If the patch cannot be
applied, then an error is returned. Note, that this function may apply a large number of
modifications in an order which cannot be determined beforehand. If the process fails, then
the network is in an undefined state.</p>
</div><h4 id="method.apply_patch" class="method"><code>pub fn <a href="#method.apply_patch" class="fnname">apply_patch</a>(&amp;mut self, patch: &amp;<a class="struct" href="../../snowcap/netsim/config/struct.ConfigPatch.html" title="struct snowcap::netsim::config::ConfigPatch">ConfigPatch</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="enum" href="../../snowcap/netsim/enum.NetworkError.html" title="enum snowcap::netsim::NetworkError">NetworkError</a>&gt;</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#261-269" title="goto source code">[src]</a></h4><div class="docblock"><p>Apply a configuration patch. The modifications of the patch are applied to the network in
the order in which they appear in <code>patch.modifiers</code>. After each modifier is applied, the
network will process all necessary messages to let the network converge. The process may
fail if the modifiers cannot be applied to the current config, or if there was a problem
while applying a modifier and letting the network converge. If the process fails, the
network is in an undefined state.</p>
</div><h4 id="method.apply_modifier" class="method"><code>pub fn <a href="#method.apply_modifier" class="fnname">apply_modifier</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;modifier: &amp;<a class="enum" href="../../snowcap/netsim/config/enum.ConfigModifier.html" title="enum snowcap::netsim::config::ConfigModifier">ConfigModifier</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="enum" href="../../snowcap/netsim/enum.NetworkError.html" title="enum snowcap::netsim::NetworkError">NetworkError</a>&gt;</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#274-283" title="goto source code">[src]</a></h4><div class="docblock"><p>Apply a single configuration modification. The modification must be applicable to the
current configuration. All messages are exchanged. The process fails, then the network is
in an undefined state, and it should be rebuilt.</p>
</div><h4 id="method.apply_modifier_check_transient" class="method"><code>pub fn <a href="#method.apply_modifier_check_transient" class="fnname">apply_modifier_check_transient</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;modifier: &amp;<a class="enum" href="../../snowcap/netsim/config/enum.ConfigModifier.html" title="enum snowcap::netsim::config::ConfigModifier">ConfigModifier</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;policy: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="enum" href="../../snowcap/hard_policies/enum.Condition.html" title="enum snowcap::hard_policies::Condition">Condition</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;n_iter: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="enum" href="../../snowcap/netsim/enum.NetworkError.html" title="enum snowcap::netsim::NetworkError">NetworkError</a>&gt;</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#299-377" title="goto source code">[src]</a></h4><div class="docblock"><h1 id="transient-condition-verification" class="section-header"><a href="#transient-condition-verification">Transient condition verification</a></h1>
<p><em>This method is only available if the <code>&quot;transient-violation&quot;</code> feature is enabled!</em></p>
<p>This function applies the modifier <code>n_iter</code> times, each time in a different ordering. At
every intermediate state, it checks the condition, which must hold at each and every state.
Notice, that for the condition, it only allows <a href="../../snowcap/hard_policies/enum.Condition.html#variant.Reachable" title="Condition::Reachable"><code>Condition::Reachable</code></a> and
<a href="../../snowcap/hard_policies/enum.Condition.html#variant.NotReachable" title="Condition::NotReachable"><code>Condition::NotReachable</code></a>. This function then returns the number of convergence series, in
which every condition is satisfied at all intermediate states of this convergence process.</p>
<p>It does this by shuffling the queue each ane very time before performing the next step. If
there exists no message to be reordered, this function returns
<a href="../../snowcap/netsim/enum.NetworkError.html#variant.NoEventsToReorder" title="NetworkError::NoEventsToReorder"><code>NetworkError::NoEventsToReorder</code></a>.</p>
</div><h4 id="method.advertise_external_route" class="method"><code>pub fn <a href="#method.advertise_external_route" class="fnname">advertise_external_route</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;source: <a class="type" href="../../snowcap/netsim/type.RouterId.html" title="type snowcap::netsim::RouterId">RouterId</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;prefix: <a class="struct" href="../../snowcap/netsim/struct.Prefix.html" title="struct snowcap::netsim::Prefix">Prefix</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;as_path: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../../snowcap/netsim/struct.AsId.html" title="struct snowcap::netsim::AsId">AsId</a>&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;med: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;community: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt;<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="enum" href="../../snowcap/netsim/enum.NetworkError.html" title="enum snowcap::netsim::NetworkError">NetworkError</a>&gt;</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#455-480" title="goto source code">[src]</a></h4><div class="docblock"><p>Advertise an external route and let the network converge, The source must be a <code>RouterId</code>
of an <code>ExternalRouter</code>. If not, an error is returned. When advertising a route, all
eBGP neighbors will receive an update with the new route. If a neighbor is added later
(after <code>advertise_external_route</code> is called), then this new neighbor will receive an update
as well.</p>
</div><h4 id="method.retract_external_route" class="method"><code>pub fn <a href="#method.retract_external_route" class="fnname">retract_external_route</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;source: <a class="type" href="../../snowcap/netsim/type.RouterId.html" title="type snowcap::netsim::RouterId">RouterId</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;prefix: <a class="struct" href="../../snowcap/netsim/struct.Prefix.html" title="struct snowcap::netsim::Prefix">Prefix</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="enum" href="../../snowcap/netsim/enum.NetworkError.html" title="enum snowcap::netsim::NetworkError">NetworkError</a>&gt;</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#484-502" title="goto source code">[src]</a></h4><div class="docblock"><p>Retract an external route and let the network converge. The source must be a <code>RouterId</code> of
an <code>ExternalRouter</code>. All current eBGP neighbors will receive a withdraw message.</p>
</div><h4 id="method.undo_action" class="method"><code>pub fn <a href="#method.undo_action" class="fnname">undo_action</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>, <a class="enum" href="../../snowcap/netsim/enum.NetworkError.html" title="enum snowcap::netsim::NetworkError">NetworkError</a>&gt;</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#518-526" title="goto source code">[src]</a></h4><div class="docblock"><p>Undo the last action of the network, causing the network to be in the earlier state. If
there was no action to be undone, then Ok(false) is returned. If something has changed,
then Ok(true) is returned.</p>
<p>The following are considered actions:</p>
<ul>
<li><code>apply_modifier</code></li>
<li><code>advertise_external_route</code></li>
<li><code>retract_external_route</code></li>
</ul>
<p>After undo, the event queue will be empty.</p>
<h1 id="warning" class="section-header"><a href="#warning">Warning</a></h1>
<p>Once the network is cloned, the copy will not contain the information to undo!</p>
</div><h4 id="method.get_forwarding_state" class="method"><code>pub fn <a href="#method.get_forwarding_state" class="fnname">get_forwarding_state</a>(&amp;self) -&gt; <a class="struct" href="../../snowcap/netsim/struct.ForwardingState.html" title="struct snowcap::netsim::ForwardingState">ForwardingState</a></code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#529-531" title="goto source code">[src]</a></h4><div class="docblock"><p>Compute and return the current forwarding state.</p>
</div><h4 id="method.get_topology" class="method"><code>pub fn <a href="#method.get_topology" class="fnname">get_topology</a>(&amp;self) -&gt; &amp;<a class="type" href="../../snowcap/netsim/type.IgpNetwork.html" title="type snowcap::netsim::IgpNetwork">IgpNetwork</a></code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#538-540" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a reference to the network topology (PetGraph struct)</p>
</div><h4 id="method.num_devices" class="method"><code>pub fn <a href="#method.num_devices" class="fnname">num_devices</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#543-545" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the number of devices in the topology</p>
</div><h4 id="method.get_device" class="method"><code>pub fn <a href="#method.get_device" class="fnname">get_device</a>(&amp;self, id: <a class="type" href="../../snowcap/netsim/type.RouterId.html" title="type snowcap::netsim::RouterId">RouterId</a>) -&gt; <a class="enum" href="../../snowcap/netsim/enum.NetworkDevice.html" title="enum snowcap::netsim::NetworkDevice">NetworkDevice</a>&lt;'_&gt;</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#548-556" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a reference to the network device.</p>
</div><h4 id="method.get_routers" class="method"><code>pub fn <a href="#method.get_routers" class="fnname">get_routers</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="../../snowcap/netsim/type.RouterId.html" title="type snowcap::netsim::RouterId">RouterId</a>&gt;</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#559-561" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a list of all internal router IDs in the network</p>
</div><h4 id="method.get_external_routers" class="method"><code>pub fn <a href="#method.get_external_routers" class="fnname">get_external_routers</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="../../snowcap/netsim/type.RouterId.html" title="type snowcap::netsim::RouterId">RouterId</a>&gt;</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#564-566" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a list of all external router IDs in the network</p>
</div><h4 id="method.get_router_id" class="method"><code>pub fn <a href="#method.get_router_id" class="fnname">get_router_id</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;name: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="type" href="../../snowcap/netsim/type.RouterId.html" title="type snowcap::netsim::RouterId">RouterId</a>, <a class="enum" href="../../snowcap/netsim/enum.NetworkError.html" title="enum snowcap::netsim::NetworkError">NetworkError</a>&gt;</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#570-590" title="goto source code">[src]</a></h4><div class="docblock"><p>Get the RouterID with the given name. If multiple routers have the same name, then the first
occurence of this name is returned. If the name was not found, an error is returned.</p>
</div><h4 id="method.get_known_prefixes" class="method"><code>pub fn <a href="#method.get_known_prefixes" class="fnname">get_known_prefixes</a>(&amp;self) -&gt; &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/std/collections/hash/set/struct.HashSet.html" title="struct std::collections::hash::set::HashSet">HashSet</a>&lt;<a class="struct" href="../../snowcap/netsim/struct.Prefix.html" title="struct snowcap::netsim::Prefix">Prefix</a>&gt;</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#593-595" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a hashset of all known prefixes</p>
</div><h4 id="method.current_config" class="method"><code>pub fn <a href="#method.current_config" class="fnname">current_config</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../snowcap/netsim/config/struct.Config.html" title="struct snowcap::netsim::config::Config">Config</a></code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#598-600" title="goto source code">[src]</a></h4><div class="docblock"><p>Return a reference to the current config.</p>
</div><h4 id="method.links_symmetric" class="method"><code>pub fn <a href="#method.links_symmetric" class="fnname">links_symmetric</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/slice/iter/struct.Iter.html" title="struct core::slice::iter::Iter">Iter</a>&lt;'_, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="type" href="../../snowcap/netsim/type.RouterId.html" title="type snowcap::netsim::RouterId">RouterId</a>, <a class="type" href="../../snowcap/netsim/type.RouterId.html" title="type snowcap::netsim::RouterId">RouterId</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>&gt;</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#603-605" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over all (undirected) links in the network.</p>
</div><h4 id="method.set_msg_limit" class="method"><code>pub fn <a href="#method.set_msg_limit" class="fnname">set_msg_limit</a>(&amp;mut self, stop_after: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;)</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#610-612" title="goto source code">[src]</a></h4><div class="docblock"><p>Configure the topology to pause the queue and return after a certain number of queue have
been executed. The job queue will remain active. If set to None, the queue will continue
running until converged.</p>
</div><h4 id="method.get_router_name" class="method"><code>pub fn <a href="#method.get_router_name" class="fnname">get_router_name</a>(&amp;self, router_id: <a class="type" href="../../snowcap/netsim/type.RouterId.html" title="type snowcap::netsim::RouterId">RouterId</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, <a class="enum" href="../../snowcap/netsim/enum.NetworkError.html" title="enum snowcap::netsim::NetworkError">NetworkError</a>&gt;</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#615-623" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the name of the router, if the ID was found.</p>
</div><h4 id="method.num_msg_exchanged" class="method"><code>pub fn <a href="#method.num_msg_exchanged" class="fnname">num_msg_exchanged</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#628-630" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the number of messages exchanged in the last operation. Such an operation might be
<code>set_config</code>, <code>apply_modifier</code>, <code>apply_patch</code>, <code>advertise_external_route</code>, .... If the
network has been cloned, then the number of msg exchanged is reset to zero.</p>
</div><h4 id="method.clear_undo_stack" class="method"><code>pub fn <a href="#method.clear_undo_stack" class="fnname">clear_undo_stack</a>(&amp;mut self)</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#634-642" title="goto source code">[src]</a></h4><div class="docblock"><p>Clear the undo stack of all routers, and reset the event history. This does not change
anything on the state of the network itself.</p>
</div><h4 id="method.get_route" class="method"><code>pub fn <a href="#method.get_route" class="fnname">get_route</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;source: <a class="type" href="../../snowcap/netsim/type.RouterId.html" title="type snowcap::netsim::RouterId">RouterId</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;prefix: <a class="struct" href="../../snowcap/netsim/struct.Prefix.html" title="struct snowcap::netsim::Prefix">Prefix</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="../../snowcap/netsim/type.RouterId.html" title="type snowcap::netsim::RouterId">RouterId</a>&gt;, <a class="enum" href="../../snowcap/netsim/enum.NetworkError.html" title="enum snowcap::netsim::NetworkError">NetworkError</a>&gt;</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#651-703" title="goto source code">[src]</a></h4><div class="docblock"><p>Return the route for the given prefix, starting at the source router, as a list of
<code>RouterIds,</code> starting at the source, and ending at the (probably external) router ID that
originated the prefix. The Router ID must be the ID of an internal router.</p>
</div><h4 id="method.print_route" class="method"><code>pub fn <a href="#method.print_route" class="fnname">print_route</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;source: <a class="type" href="../../snowcap/netsim/type.RouterId.html" title="type snowcap::netsim::RouterId">RouterId</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;prefix: <a class="struct" href="../../snowcap/netsim/struct.Prefix.html" title="struct snowcap::netsim::Prefix">Prefix</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="enum" href="../../snowcap/netsim/enum.NetworkError.html" title="enum snowcap::netsim::NetworkError">NetworkError</a>&gt;</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#708-738" title="goto source code">[src]</a></h4><div class="docblock"><p>Print the route of a routerID to the destination. This is a helper function, wrapping
<code>self.get_route(source, prefix)</code> inside some print statements. The router ID must he the ID
of an internal router</p>
</div><h4 id="method.print_igp_fw_table" class="method"><code>pub fn <a href="#method.print_igp_fw_table" class="fnname">print_igp_fw_table</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;router_id: <a class="type" href="../../snowcap/netsim/type.RouterId.html" title="type snowcap::netsim::RouterId">RouterId</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="enum" href="../../snowcap/netsim/enum.NetworkError.html" title="enum snowcap::netsim::NetworkError">NetworkError</a>&gt;</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#741-766" title="goto source code">[src]</a></h4><div class="docblock"><p>Print the igp forwarding table for a specific router.</p>
</div><h4 id="method.weak_eq" class="method"><code>pub fn <a href="#method.weak_eq" class="fnname">weak_eq</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#771-792" title="goto source code">[src]</a></h4><div class="docblock"><p>Checks for weak equivalence, by only comparing the BGP tables. This funciton assumes that
both networks have identical routers, identical topologies, identical configuration and that
the same routes are advertised by the same external routers.</p>
</div></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><h3 id="impl-Clone" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="../../snowcap/netsim/struct.Network.html" title="struct snowcap::netsim::Network">Network</a></code><a href="#impl-Clone" class="anchor"></a><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#153-170" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.clone" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; Self</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#155-169" title="goto source code">[src]</a></h4><div class="docblock"><p>Cloning the network does not clone the event history, and any of the undo traces.</p>
</div><h4 id="method.clone_from" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self)</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#128" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><h3 id="impl-Debug" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="../../snowcap/netsim/struct.Network.html" title="struct snowcap::netsim::Network">Network</a></code><a href="#impl-Debug" class="anchor"></a><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#46" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.fmt" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#46" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id="impl-Default" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="../../snowcap/netsim/struct.Network.html" title="struct snowcap::netsim::Network">Network</a></code><a href="#impl-Default" class="anchor"></a><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#172-176" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.default" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; Self</code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#173-175" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns the &quot;default value&quot; for a type. <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></div><h3 id="impl-PartialEq%3CNetwork%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../../snowcap/netsim/struct.Network.html" title="struct snowcap::netsim::Network">Network</a>&gt; for <a class="struct" href="../../snowcap/netsim/struct.Network.html" title="struct snowcap::netsim::Network">Network</a></code><a href="#impl-PartialEq%3CNetwork%3E" class="anchor"></a><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#1729-1761" title="goto source code">[src]</a></h3><div class="docblock"><p>The <code>PartialEq</code> implementation checks if two networks are identica. The implementation first
checks &quot;simple&quot; conditions, like the configuration, before checking the state of each individual
router. Use the <code>Network::weak_eq</code> function to skip some checks, which can be known beforehand.
This implementation will check the configuration, advertised prefixes and all routers.</p>
</div><div class="impl-items"><h4 id="method.eq" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../../src/snowcap/netsim/network.rs.html#1730-1760" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id="method.ne" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#213" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><h3 id="impl-RefUnwindSafe" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="../../snowcap/netsim/struct.Network.html" title="struct snowcap::netsim::Network">Network</a></code><a href="#impl-RefUnwindSafe" class="anchor"></a><a class="srclink" href="../../src/snowcap/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Send" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../../snowcap/netsim/struct.Network.html" title="struct snowcap::netsim::Network">Network</a></code><a href="#impl-Send" class="anchor"></a><a class="srclink" href="../../src/snowcap/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Sync" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../../snowcap/netsim/struct.Network.html" title="struct snowcap::netsim::Network">Network</a></code><a href="#impl-Sync" class="anchor"></a><a class="srclink" href="../../src/snowcap/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Unpin" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="../../snowcap/netsim/struct.Network.html" title="struct snowcap::netsim::Network">Network</a></code><a href="#impl-Unpin" class="anchor"></a><a class="srclink" href="../../src/snowcap/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-UnwindSafe" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="../../snowcap/netsim/struct.Network.html" title="struct snowcap::netsim::Network">Network</a></code><a href="#impl-UnwindSafe" class="anchor"></a><a class="srclink" href="../../src/snowcap/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><h3 id="impl-Any" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Any" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#131-135" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.type_id" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#132" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div><h3 id="impl-Borrow%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Borrow%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#207-211" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id="impl-BorrowMut%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214-218" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow_mut" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#215" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id="impl-From%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</code><a href="#impl-From%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#545-549" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#546" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-Into%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-Into%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#534-541" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#538" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-ToOwned" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></code><a href="#impl-ToOwned" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#80-92" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Owned" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</code></h4><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div><h4 id="method.to_owned" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#85" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div><h4 id="method.clone_into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T)</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89" title="goto source code">[src]</a></h4><div class="item-info hidden"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</summary><p>recently added</p>
</details></div></div><div class='docblock hidden'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></div><h3 id="impl-TryFrom%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#582-591" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_from" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#588" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-TryInto%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryInto%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#568-577" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error-1" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#574" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-VZip%3CV%3E" class="impl"><code class="in-band">impl&lt;V, T&gt; <a class="trait" href="../../ppv_lite86/types/trait.VZip.html" title="trait ppv_lite86::types::VZip">VZip</a>&lt;V&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../ppv_lite86/types/trait.MultiLane.html" title="trait ppv_lite86::types::MultiLane">MultiLane</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-VZip%3CV%3E" class="anchor"></a><a class="srclink" href="../../src/ppv_lite86/types.rs.html#211-219" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.vzip" class="method hidden"><code>pub fn <a href="../../ppv_lite86/types/trait.VZip.html#tymethod.vzip" class="fnname">vzip</a>(self) -&gt; V</code><a class="srclink" href="../../src/ppv_lite86/types.rs.html#216" title="goto source code">[src]</a></h4></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="snowcap"></div>
    <script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>