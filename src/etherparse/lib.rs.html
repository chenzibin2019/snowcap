<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/tibor/.local/share/cargo/registry/src/github.com-1ecc6299db9ec823/etherparse-0.9.0/src/lib.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>lib.rs - source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../etherparse/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
</pre><div class="example-wrap"><pre class="rust ">
<span class="doccomment">//! A zero allocation library for parsing &amp; writing a bunch of packet based protocols (EthernetII, IPv4, IPv6, UDP, TCP ...).</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Currently supported are:</span>
<span class="doccomment">//! * Ethernet II</span>
<span class="doccomment">//! * IEEE 802.1Q VLAN Tagging Header</span>
<span class="doccomment">//! * IPv4</span>
<span class="doccomment">//! * IPv6 (missing extension headers, but supporting skipping them)</span>
<span class="doccomment">//! * UDP</span>
<span class="doccomment">//! * TCP</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! # Usage</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! First, add the following to your `Cargo.toml`:</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```toml</span>
<span class="doccomment">//! [dependencies]</span>
<span class="doccomment">//! etherparse = &quot;0.9.0&quot;</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Next, add this to your crate root:</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! extern crate etherparse;</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! # What is etherparse?</span>
<span class="doccomment">//! Etherparse is intended to provide the basic network parsing functions that allow for easy analysis, transformation or generation of recorded network data.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Some key points are:</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! * It is completly written in Rust and thoroughly tested.</span>
<span class="doccomment">//! * Special attention has been paid to not use allocations or syscalls.</span>
<span class="doccomment">//! * The package is still in development and can &amp; will still change. </span>
<span class="doccomment">//! * The current focus of development is on the most popular protocols in the internet &amp; transport layer.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! # How to parse network packages?</span>
<span class="doccomment">//! Etherparse gives you two options for parsing network packages automatically:</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ## Slicing the packet</span>
<span class="doccomment">//! Here the different components in a packet are seperated without parsing all their fields. For each header a slice is generated that allows access to the fields of a header.</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! # use etherparse::{SlicedPacket, PacketBuilder};</span>
<span class="doccomment">//! # let builder = PacketBuilder::</span>
<span class="doccomment">//! #    ethernet2([1,2,3,4,5,6],     //source mac</span>
<span class="doccomment">//! #               [7,8,9,10,11,12]) //destionation mac</span>
<span class="doccomment">//! #    .ipv4([192,168,1,1], //source ip</span>
<span class="doccomment">//! #          [192,168,1,2], //desitionation ip</span>
<span class="doccomment">//! #          20)            //time to life</span>
<span class="doccomment">//! #    .udp(21,    //source port </span>
<span class="doccomment">//! #         1234); //desitnation port</span>
<span class="doccomment">//! #    //payload of the udp packet</span>
<span class="doccomment">//! #    let payload = [1,2,3,4,5,6,7,8];</span>
<span class="doccomment">//! #    //get some memory to store the serialized data</span>
<span class="doccomment">//! #    let mut packet = Vec::&lt;u8&gt;::with_capacity(</span>
<span class="doccomment">//! #                            builder.size(payload.len()));</span>
<span class="doccomment">//! #    builder.write(&amp;mut packet, &amp;payload).unwrap();</span>
<span class="doccomment">//! match SlicedPacket::from_ethernet(&amp;packet) {</span>
<span class="doccomment">//!     Err(value) =&gt; println!(&quot;Err {:?}&quot;, value),</span>
<span class="doccomment">//!     Ok(value) =&gt; {</span>
<span class="doccomment">//!         println!(&quot;link: {:?}&quot;, value.link);</span>
<span class="doccomment">//!         println!(&quot;vlan: {:?}&quot;, value.vlan);</span>
<span class="doccomment">//!         println!(&quot;ip: {:?}&quot;, value.ip);</span>
<span class="doccomment">//!         println!(&quot;transport: {:?}&quot;, value.transport);</span>
<span class="doccomment">//!     }</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! This is the faster option if your code is not interested in all fields of all the headers. It is a good choice if you just want filter or find packages based on a subset of the headers and/or their fields.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Depending from which point downward you want to slice a package check out the functions:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * [`SlicedPacket.from_ethernet`](struct.SlicedPacket.html#method.from_ethernet) for parsing from an Ethernet II header downwards</span>
<span class="doccomment">//! * [`SlicedPacket.from_ip`](struct.SlicedPacket.html#method.from_ip) for parsing from an IPv4 or IPv6 downwards</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Deserializing all headers into structs</span>
<span class="doccomment">//! This option deserializes all known headers and transferes their contents to header structs.</span>
<span class="doccomment">//! ```rust</span>
<span class="doccomment">//! # use etherparse::{PacketHeaders, PacketBuilder};</span>
<span class="doccomment">//! # let builder = PacketBuilder::</span>
<span class="doccomment">//! #    ethernet2([1,2,3,4,5,6],     //source mac</span>
<span class="doccomment">//! #               [7,8,9,10,11,12]) //destionation mac</span>
<span class="doccomment">//! #    .ipv4([192,168,1,1], //source ip</span>
<span class="doccomment">//! #          [192,168,1,2], //desitionation ip</span>
<span class="doccomment">//! #          20)            //time to life</span>
<span class="doccomment">//! #    .udp(21,    //source port </span>
<span class="doccomment">//! #         1234); //desitnation port</span>
<span class="doccomment">//! #    //payload of the udp packet</span>
<span class="doccomment">//! #    let payload = [1,2,3,4,5,6,7,8];</span>
<span class="doccomment">//! #    //get some memory to store the serialized data</span>
<span class="doccomment">//! #    let mut packet = Vec::&lt;u8&gt;::with_capacity(</span>
<span class="doccomment">//! #                            builder.size(payload.len()));</span>
<span class="doccomment">//! #    builder.write(&amp;mut packet, &amp;payload).unwrap();</span>
<span class="doccomment">//! match PacketHeaders::from_ethernet_slice(&amp;packet) {</span>
<span class="doccomment">//!     Err(value) =&gt; println!(&quot;Err {:?}&quot;, value),</span>
<span class="doccomment">//!     Ok(value) =&gt; {</span>
<span class="doccomment">//!         println!(&quot;link: {:?}&quot;, value.link);</span>
<span class="doccomment">//!         println!(&quot;vlan: {:?}&quot;, value.vlan);</span>
<span class="doccomment">//!         println!(&quot;ip: {:?}&quot;, value.ip);</span>
<span class="doccomment">//!         println!(&quot;transport: {:?}&quot;, value.transport);</span>
<span class="doccomment">//!     }</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! This option is slower then slicing when only few fields are accessed. But it can be the faster option or useful if you are interested in most fields anyways or if you want to re-serialize the headers with modified values.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Depending from which point downward you want to unpack a package check out the functions</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * [`PacketHeaders.from_ethernet_slice`](struct.PacketHeaders.html#method.from_ethernet_slice) for parsing from an Ethernet II header downwards</span>
<span class="doccomment">//! * [`PacketHeaders.from_ip_slice`](struct.PacketHeaders.html#method.from_ip_slice) for parsing from an IPv4 or IPv6 downwards</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Manually slicing &amp; parsing packets</span>
<span class="doccomment">//! It is also possible to manually slice &amp; parse a packet. For each header type there is are metods that create a slice or struct from a memory slice. </span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Have a look at the documentation for the &lt;NAME&gt;Slice.from_slice methods, if you want to create your own slices:</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! * [`Ethernet2HeaderSlice.from_slice`](struct.Ethernet2HeaderSlice.html#method.from_slice)</span>
<span class="doccomment">//! * [`SingleVlanHeaderSlice.from_slice`](struct.SingleVlanHeaderSlice.html#method.from_slice)</span>
<span class="doccomment">//! * [`DoubleVlanHeaderSlice.from_slice`](struct.DoubleVlanHeaderSlice.html#method.from_slice)</span>
<span class="doccomment">//! * [`Ipv4HeaderSlice.from_slice`](struct.Ipv4HeaderSlice.html#method.from_slice)</span>
<span class="doccomment">//! * [`Ipv6HeaderSlice.from_slice`](struct.Ipv6HeaderSlice.html#method.from_slice)</span>
<span class="doccomment">//! * [`Ipv6ExtensionHeaderSlice.from_slice`](struct.Ipv6ExtensionHeaderSlice.html)</span>
<span class="doccomment">//! * [`UdpHeaderSlice.from_slice`](struct.UdpHeaderSlice.html#method.from_slice)</span>
<span class="doccomment">//! * [`TcpHeaderSlice.from_slice`](struct.TcpHeaderSlice.html#method.from_slice)</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! And for deserialization into the corresponding header structs have a look at:</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! * [`Ethernet2Header.read`](struct.Ethernet2Header.html#method.read) &amp; [`Ethernet2Header.read_from_slice`](struct.Ethernet2Header.html#method.read_from_slice)</span>
<span class="doccomment">//! * [`SingleVlanHeader.read`](struct.SingleVlanHeader.html#method.read) &amp; [`SingleVlanHeader.read_from_slice`](struct.SingleVlanHeader.html#method.read_from_slice)</span>
<span class="doccomment">//! * [`DoubleVlanHeader.read`](struct.DoubleVlanHeader.html#method.read) &amp; [`DoubleVlanHeader.read_from_slice`](struct.DoubleVlanHeader.html#method.read_from_slice)</span>
<span class="doccomment">//! * [`IpHeader.read`](enum.IpHeader.html#method.read) &amp; [`IpHeader.read_from_slice`](enum.IpHeader.html#method.read_from_slice)</span>
<span class="doccomment">//! * [`Ipv4Header.read`](struct.Ipv4Header.html#method.read) &amp; [`Ipv4Header.read_from_slice`](struct.Ipv4Header.html#method.read_from_slice)</span>
<span class="doccomment">//! * [`Ipv6Header.read`](struct.Ipv6Header.html#method.read) &amp; [`Ipv6Header.read_from_slice`](struct.Ipv6Header.html#method.read_from_slice)</span>
<span class="doccomment">//! * [`UdpHeader.read`](struct.UdpHeader.html#method.read) &amp; [`UdpHeader.read_from_slice`](struct.UdpHeader.html#method.read_from_slice)</span>
<span class="doccomment">//! * [`TcpHeader.read`](struct.TcpHeader.html#method.read) &amp; [`TcpHeader.read_from_slice`](struct.TcpHeader.html#method.read_from_slice)</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! # How to generate fake packet data?</span>
<span class="doccomment">//! ## Packet Builder</span>
<span class="doccomment">//! The PacketBuilder struct provides a high level interface for quickly creating network packets. The PacketBuilder will automatically set fields which can be deduced from the content and compositions of the packet itself (e.g. checksums, lengths, ethertype, ip protocol number).</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! [Example:](https://github.com/JulianSchmid/etherparse/blob/0.8.0/examples/write_udp.rs)</span>
<span class="doccomment">//! ```rust</span>
<span class="doccomment">//! use etherparse::PacketBuilder;</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! let builder = PacketBuilder::</span>
<span class="doccomment">//!     ethernet2([1,2,3,4,5,6],     //source mac</span>
<span class="doccomment">//!                [7,8,9,10,11,12]) //destination mac</span>
<span class="doccomment">//!     .ipv4([192,168,1,1], //source ip</span>
<span class="doccomment">//!           [192,168,1,2], //desitination ip</span>
<span class="doccomment">//!           20)            //time to life</span>
<span class="doccomment">//!     .udp(21,    //source port </span>
<span class="doccomment">//!          1234); //desitnation port</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! //payload of the udp packet</span>
<span class="doccomment">//! let payload = [1,2,3,4,5,6,7,8];</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! //get some memory to store the result</span>
<span class="doccomment">//! let mut result = Vec::&lt;u8&gt;::with_capacity(builder.size(payload.len()));</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! //serialize</span>
<span class="doccomment">//! //this will automatically set all length fields, checksums and identifiers (ethertype &amp; protocol)</span>
<span class="doccomment">//! //before writing the packet out to &quot;result&quot;</span>
<span class="doccomment">//! builder.write(&amp;mut result, &amp;payload).unwrap();</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! There is also an [example for TCP packets](https://github.com/JulianSchmid/etherparse/blob/0.8.0/examples/write_tcp.rs) available.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Check out the [PacketBuilder documentation](struct.PacketBuilder.html) for more informations.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ## Manually serialising each header</span>
<span class="doccomment">//! Alternativly it is possible to manually build a packet ([example](https://github.com/JulianSchmid/etherparse/blob/0.8.0/examples/write_ipv4_udp.rs)). Generally each struct representing a header has a &quot;write&quot; method that allows it to be serialized. These write methods sometimes automatically calculate checksums and fill them in. In case this is unwanted behavior (e.g. if you want to generate a packet with an invalid checksum), it is also possible to call a &quot;write_raw&quot; method that will simply serialize the data without doing checksum calculations.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Read the documentations of the different methods for a more details:</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! * [`Ethernet2Header.write`](struct.Ethernet2Header.html#method.write)</span>
<span class="doccomment">//! * [`SingleVlanHeader.write`](struct.SingleVlanHeader.html#method.write)</span>
<span class="doccomment">//! * [`DoubleVlanHeader.write`](struct.DoubleVlanHeader.html#method.write)</span>
<span class="doccomment">//! * [`Ipv4Header.write`](struct.Ipv4Header.html#method.write)</span>
<span class="doccomment">//! * [`Ipv4Header.write_raw`](struct.Ipv4Header.html#method.write_raw)</span>
<span class="doccomment">//! * [`Ipv6Header.write`](struct.Ipv6Header.html#method.write)</span>
<span class="doccomment">//! * [`UdpHeader.write`](struct.UdpHeader.html#method.write)</span>
<span class="doccomment">//! * [`TcpHeader.write`](struct.TcpHeader.html#method.write)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! # Roadmap</span>
<span class="doccomment">//! * Documentation</span>
<span class="doccomment">//!   * Packet Builder</span>
<span class="doccomment">//! * MutPacketSlice -&gt; modifaction of fields in slices directly?</span>
<span class="doccomment">//! * Reserializing SlicedPacket &amp; MutSlicedPacket with corrected checksums &amp; id&#39;s</span>
<span class="doccomment">//! * Slicing &amp; reading packet from different layers then ethernet onward (e.g. ip, vlan...)</span>
<span class="doccomment">//! * IEEE 802.3</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! # References</span>
<span class="doccomment">//! * Darpa Internet Program Protocol Specification [RFC 791](https://tools.ietf.org/html/rfc791)</span>
<span class="doccomment">//! * Internet Protocol, Version 6 (IPv6) Specification [RFC 8200](https://tools.ietf.org/html/rfc8200)</span>
<span class="doccomment">//! * [IANA Protocol Numbers](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)</span>
<span class="doccomment">//! * [Internet Protocol Version 6 (IPv6) Parameters](https://www.iana.org/assignments/ipv6-parameters/ipv6-parameters.xhtml)</span>
<span class="doccomment">//! * [Wikipedia IEEE_802.1Q](https://en.wikipedia.org/w/index.php?title=IEEE_802.1Q&amp;oldid=820983900)</span>
<span class="doccomment">//! * User Datagram Protocol (UDP) [RFC 768](https://tools.ietf.org/html/rfc768)</span>
<span class="doccomment">//! * Transmission Control Protocol [RFC 793](https://tools.ietf.org/html/rfc793)</span>
<span class="doccomment">//! * TCP Extensions for High Performance [RFC 7323](https://tools.ietf.org/html/rfc7323)</span>
<span class="doccomment">//! * The Addition of Explicit Congestion Notification (ECN) to IP [RFC 3168](https://tools.ietf.org/html/rfc3168)</span>
<span class="doccomment">//! * Robust Explicit Congestion Notification (ECN) Signaling with Nonces [RFC 3540](https://tools.ietf.org/html/rfc3540)</span>

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fmt</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;

<span class="kw">mod</span> <span class="ident">link</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">link</span>::<span class="ident">ethernet</span>::<span class="kw-2">*</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">link</span>::<span class="ident">vlan_tagging</span>::<span class="kw-2">*</span>;

<span class="kw">mod</span> <span class="ident">internet</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">internet</span>::<span class="ident">ip</span>::<span class="kw-2">*</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">internet</span>::<span class="ident">ipv4</span>::<span class="kw-2">*</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">internet</span>::<span class="ident">ipv6</span>::<span class="kw-2">*</span>;

<span class="kw">mod</span> <span class="ident">transport</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">transport</span>::<span class="ident">tcp</span>::<span class="kw-2">*</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">transport</span>::<span class="ident">udp</span>::<span class="kw-2">*</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">transport</span>::<span class="ident">TransportHeader</span>;

<span class="kw">mod</span> <span class="ident">packet_builder</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">packet_builder</span>::<span class="kw-2">*</span>;

<span class="kw">mod</span> <span class="ident">packet_decoder</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">packet_decoder</span>::<span class="kw-2">*</span>;

<span class="kw">mod</span> <span class="ident">packet_slicing</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">packet_slicing</span>::<span class="kw-2">*</span>;

<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">packet_filter</span>;

<span class="doccomment">///Contains the size when serialized.</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">SerializedSize</span> {
    <span class="kw">const</span> <span class="ident">SERIALIZED_SIZE</span>: <span class="ident">usize</span>;
}

<span class="doccomment">///Errors that can occur when reading.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">ReadError</span> {
    <span class="ident">IoError</span>(<span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">Error</span>),
    <span class="doccomment">///Error when an unexpected end of a slice was reached even though more data was expected to be present (expected minimum size as argument).</span>
    <span class="ident">UnexpectedEndOfSlice</span>(<span class="ident">usize</span>),
    <span class="doccomment">///Error when a double vlan tag was expected but the tpid of the outer vlan does not contain the expected id of 0x8100.</span>
    <span class="ident">VlanDoubleTaggingUnexpectedOuterTpid</span>(<span class="ident">u16</span>),
    <span class="doccomment">///Error when the ip header version is not supported (only 4 &amp; 6 are supported). The value is the version that was received.</span>
    <span class="ident">IpUnsupportedVersion</span>(<span class="ident">u8</span>),
    <span class="doccomment">///Error when the ip header version field is not equal 4. The value is the version that was received.</span>
    <span class="ident">Ipv4UnexpectedVersion</span>(<span class="ident">u8</span>),
    <span class="doccomment">///Error when the ipv4 header length is smaller then the header itself (5).</span>
    <span class="ident">Ipv4HeaderLengthBad</span>(<span class="ident">u8</span>),
    <span class="doccomment">///Error when the total length field is too small to contain the header itself.</span>
    <span class="ident">Ipv4TotalLengthTooSmall</span>(<span class="ident">u16</span>),
    <span class="doccomment">///Error when then ip header version field is not equal 6. The value is the version that was received.</span>
    <span class="ident">Ipv6UnexpectedVersion</span>(<span class="ident">u8</span>),
    <span class="doccomment">///Error when more then 7 header extensions are present (according to RFC82000 this should never happen).</span>
    <span class="ident">Ipv6TooManyHeaderExtensions</span>,
    <span class="doccomment">///Error given if the data_offset field in a TCP header is smaller then the minimum size of the tcp header itself.</span>
    <span class="ident">TcpDataOffsetTooSmall</span>(<span class="ident">u8</span>),
}

<span class="kw">impl</span> <span class="ident">ReadError</span> {
    <span class="doccomment">///Adds an offset value to the UnexpectedEndOfSlice error.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">add_slice_offset</span>(<span class="self">self</span>, <span class="ident">offset</span>: <span class="ident">usize</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">ReadError</span> {
        <span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">ReadError</span>::<span class="kw-2">*</span>;
        <span class="kw">match</span> <span class="self">self</span> {
            <span class="ident">UnexpectedEndOfSlice</span>(<span class="ident">value</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">UnexpectedEndOfSlice</span>(<span class="ident">value</span> <span class="op">+</span> <span class="ident">offset</span>),
            <span class="ident">value</span> <span class="op">=</span><span class="op">&gt;</span> <span class="ident">value</span>
        }
    }
}


<span class="kw">impl</span> <span class="ident">fmt</span>::<span class="ident">Display</span> <span class="kw">for</span> <span class="ident">ReadError</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">fmt</span>::<span class="ident">Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">fmt</span>::<span class="prelude-ty">Result</span> {
        <span class="kw">use</span> <span class="ident">ReadError</span>::<span class="kw-2">*</span>;

        <span class="kw">match</span> <span class="self">self</span> {
            <span class="ident">IoError</span>(<span class="ident">err</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">err</span>.<span class="ident">fmt</span>(<span class="ident">f</span>),
            <span class="ident">UnexpectedEndOfSlice</span>(<span class="ident">expected_minimum_size</span>) <span class="op">=</span><span class="op">&gt;</span> { <span class="comment">// usize</span>
                <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;ReadError: Unexpected end of slice. The given slice contained less then minimum required {} bytes.&quot;</span>, <span class="ident">expected_minimum_size</span>)
            },
            <span class="ident">VlanDoubleTaggingUnexpectedOuterTpid</span>(<span class="ident">tpid</span>) <span class="op">=</span><span class="op">&gt;</span> { <span class="comment">//u16</span>
                <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;ReadError: Expected a double vlan header, but the outer tpid {} is a non vlan header tpid.&quot;</span>, <span class="ident">tpid</span>)
            },
            <span class="ident">IpUnsupportedVersion</span>(<span class="ident">version_number</span>) <span class="op">=</span><span class="op">&gt;</span> { <span class="comment">// u8</span>
                <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;ReadError: Unsupported IP version number. The IP header contained the unsupported version number {}.&quot;</span>, <span class="ident">version_number</span>)
            },
            <span class="ident">Ipv4UnexpectedVersion</span>(<span class="ident">version_number</span>) <span class="op">=</span><span class="op">&gt;</span> { <span class="comment">//u8</span>
                <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;ReadError: Unexpected IP version number. Expected an IPv4 Header but the header contained the version number {}.&quot;</span>, <span class="ident">version_number</span>)
            },
            <span class="ident">Ipv4HeaderLengthBad</span>(<span class="ident">header_length</span>) <span class="op">=</span><span class="op">&gt;</span> { <span class="comment">//u8</span>
                <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;ReadError: Bad IPv4 header length. The header length value {} in the IPv4 header is smaller then the ipv4 header.&quot;</span>, <span class="ident">header_length</span>)
            },
            <span class="ident">Ipv4TotalLengthTooSmall</span>(<span class="ident">total_length_field</span>) <span class="op">=</span><span class="op">&gt;</span> { <span class="comment">//u16</span>
                <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;ReadError: Bad IPv4 total length. The total length value {} in the IPv4 header is smaller then the ipv4 header itself.&quot;</span>, <span class="ident">total_length_field</span>)
            },
            <span class="ident">Ipv6UnexpectedVersion</span>(<span class="ident">version_number</span>) <span class="op">=</span><span class="op">&gt;</span> { <span class="comment">//u8</span>
                <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;ReadError: Unexpected IP version number. Expected an IPv6 Header but the header contained the version number {}.&quot;</span>, <span class="ident">version_number</span>)
            },
            <span class="ident">Ipv6TooManyHeaderExtensions</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;ReadError: Too many IPv6 header extensions. There are more then 7 extension headers present, this not supported.&quot;</span>)
            },
            <span class="ident">TcpDataOffsetTooSmall</span>(<span class="ident">data_offset</span>) <span class="op">=</span><span class="op">&gt;</span> { <span class="comment">//u8</span>
                <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;ReadError: TCP data offset too small. The data offset value {} in the tcp header is smaller then the tcp header itself.&quot;</span>, <span class="ident">data_offset</span>)
            },
        }
    }
}

<span class="kw">impl</span> <span class="ident">Error</span> <span class="kw">for</span> <span class="ident">ReadError</span> {
    <span class="kw">fn</span> <span class="ident">source</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>(<span class="kw">dyn</span> <span class="ident">Error</span> <span class="op">+</span> <span class="lifetime">&#39;static</span>)<span class="op">&gt;</span> {
        <span class="kw">match</span> <span class="self">self</span> {
            <span class="ident">ReadError</span>::<span class="ident">IoError</span>(<span class="kw-2">ref</span> <span class="ident">err</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Some</span>(<span class="ident">err</span>),
            <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">None</span>
        }
    }
}

<span class="kw">impl</span> <span class="ident">From</span><span class="op">&lt;</span><span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">Error</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">ReadError</span> {
    <span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">err</span>: <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">Error</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">ReadError</span> {
        <span class="ident">ReadError</span>::<span class="ident">IoError</span>(<span class="ident">err</span>)
    }
}

<span class="doccomment">///Errors that can occur when writing.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">WriteError</span> {
    <span class="ident">IoError</span>(<span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">Error</span>),
    <span class="doccomment">///Error in the data that was given to write</span>
    <span class="ident">ValueError</span>(<span class="ident">ValueError</span>),
    <span class="doccomment">///Error when a given slice is not big enough to serialize the data.</span>
    <span class="ident">SliceTooSmall</span>(<span class="ident">usize</span>),
}

<span class="kw">impl</span> <span class="ident">WriteError</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">value_error</span>(<span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">ValueError</span><span class="op">&gt;</span> {

        <span class="kw">match</span> <span class="self">self</span> {
            <span class="ident">WriteError</span>::<span class="ident">ValueError</span>(<span class="ident">value</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Some</span>(<span class="ident">value</span>),
            <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">None</span>
        }
    }
}

<span class="kw">impl</span> <span class="ident">From</span><span class="op">&lt;</span><span class="ident">ValueError</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">WriteError</span> {
    <span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">err</span>: <span class="ident">ValueError</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">WriteError</span> {
        <span class="ident">WriteError</span>::<span class="ident">ValueError</span>(<span class="ident">err</span>)
    }
}

<span class="kw">impl</span> <span class="ident">From</span><span class="op">&lt;</span><span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">Error</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">WriteError</span> {
    <span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">err</span>: <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">Error</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">WriteError</span> {
        <span class="ident">WriteError</span>::<span class="ident">IoError</span>(<span class="ident">err</span>)
    }
}

<span class="kw">impl</span> <span class="ident">fmt</span>::<span class="ident">Display</span> <span class="kw">for</span> <span class="ident">WriteError</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">fmt</span>::<span class="ident">Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">fmt</span>::<span class="prelude-ty">Result</span> {
        <span class="kw">use</span> <span class="ident">WriteError</span>::<span class="kw-2">*</span>;
        <span class="kw">match</span> <span class="self">self</span> {
            <span class="ident">IoError</span>(<span class="ident">err</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">err</span>.<span class="ident">fmt</span>(<span class="ident">f</span>),
            <span class="ident">ValueError</span>(<span class="ident">err</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;ValueError: {}&quot;</span>, <span class="ident">err</span>)
            },
            <span class="ident">SliceTooSmall</span>(<span class="ident">size</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;SliceTooSmall: The slice given to write to is too small (required to be at least {} bytes large)&quot;</span>, <span class="ident">size</span>)
            }
        }
    }
}

<span class="kw">impl</span> <span class="ident">Error</span> <span class="kw">for</span> <span class="ident">WriteError</span> {
    <span class="kw">fn</span> <span class="ident">source</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>(<span class="kw">dyn</span> <span class="ident">Error</span> <span class="op">+</span> <span class="lifetime">&#39;static</span>)<span class="op">&gt;</span> {
        <span class="kw">use</span> <span class="ident">WriteError</span>::<span class="kw-2">*</span>;
        <span class="kw">match</span> <span class="self">self</span> {
            <span class="ident">IoError</span>(<span class="kw-2">ref</span> <span class="ident">err</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Some</span>(<span class="ident">err</span>),
            <span class="ident">ValueError</span>(<span class="kw-2">ref</span> <span class="ident">err</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Some</span>(<span class="ident">err</span>),
            <span class="ident">SliceTooSmall</span>(<span class="kw">_</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">None</span>
        }
    }
}

<span class="doccomment">///Errors in the given data</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>, <span class="ident">Clone</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">ValueError</span> {
    <span class="doccomment">///Error when the ipv4 options length is too big or not aligned (cannot be bigger then 40 bytes and must be a multiple of 4 bytes).</span>
    <span class="ident">Ipv4OptionsLengthBad</span>(<span class="ident">usize</span>),
    <span class="doccomment">///Error when a given payload &amp; ipv4 header is bigger then what fits inside an ipv4 total_length field.</span>
    <span class="ident">Ipv4PayloadLengthTooLarge</span>(<span class="ident">usize</span>),
    <span class="doccomment">///Error when a given payload &amp; ipv6 header block is bigger then what fits inside an ipv6 payload_length field.</span>
    <span class="ident">Ipv6PayloadLengthTooLarge</span>(<span class="ident">usize</span>),
    <span class="doccomment">///Error when a given payload is bigger then what fits inside an udp packet</span>
    <span class="doccomment">///Note that a the maximum payload size, as far as udp is conceirned, is max_value(u16) - 8. The 8 is for the size of the udp header itself.</span>
    <span class="ident">UdpPayloadLengthTooLarge</span>(<span class="ident">usize</span>),
    <span class="doccomment">///Error when a given payload + tcp header options is bigger then what fits inside an tcp packet</span>
    <span class="doccomment">///Note that a the maximum size, as far as tcp is conceirned, is max_value(u16) - tcp_header.data_offset()*4. The data_offset is for the size of the udp header itself.</span>
    <span class="ident">TcpLengthTooLarge</span>(<span class="ident">usize</span>),
    <span class="doccomment">///Error when a u8 field in a header has a larger value then supported.</span>
    <span class="ident">U8TooLarge</span>{<span class="ident">value</span>: <span class="ident">u8</span>, <span class="ident">max</span>: <span class="ident">u8</span>, <span class="ident">field</span>: <span class="ident">ErrorField</span>},
    <span class="doccomment">///Error when a u16 field in a header has a larger value then supported.</span>
    <span class="ident">U16TooLarge</span>{<span class="ident">value</span>: <span class="ident">u16</span>, <span class="ident">max</span>: <span class="ident">u16</span>, <span class="ident">field</span>: <span class="ident">ErrorField</span>},
    <span class="doccomment">///Error when a u32 field in a header has a larger value then supported.</span>
    <span class="ident">U32TooLarge</span>{<span class="ident">value</span>: <span class="ident">u32</span>, <span class="ident">max</span>: <span class="ident">u32</span>, <span class="ident">field</span>: <span class="ident">ErrorField</span>}
}

<span class="kw">impl</span> <span class="ident">Error</span> <span class="kw">for</span> <span class="ident">ValueError</span> {

}

<span class="kw">impl</span> <span class="ident">fmt</span>::<span class="ident">Display</span> <span class="kw">for</span> <span class="ident">ValueError</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">fmt</span>::<span class="ident">Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">fmt</span>::<span class="prelude-ty">Result</span> {
        <span class="kw">use</span> <span class="ident">ValueError</span>::<span class="kw-2">*</span>;
        <span class="kw">match</span> <span class="self">self</span> {
            <span class="ident">Ipv4OptionsLengthBad</span>(<span class="ident">options_len</span>) <span class="op">=</span><span class="op">&gt;</span> { <span class="comment">//usize</span>
                <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;Bad IPv4 &#39;options_len&#39;. The IPv4 options length ({} bytes) is either not a multiple of 4 bytes or bigger then the maximum of 40 bytes.&quot;</span>, <span class="ident">options_len</span>)
            },
            <span class="ident">Ipv4PayloadLengthTooLarge</span>(<span class="ident">total_length</span>) <span class="op">=</span><span class="op">&gt;</span> { <span class="comment">//usize</span>
                <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;IPv4 &#39;total_legnth&#39; too large. The IPv4 header and payload have a larger size ({} bytes) than can be be represented by the &#39;total_legnth&#39; field in the IPv4 header.&quot;</span>, <span class="ident">total_length</span>)
            },
            <span class="ident">Ipv6PayloadLengthTooLarge</span>(<span class="ident">size</span>) <span class="op">=</span><span class="op">&gt;</span> { <span class="comment">//usize</span>
                <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;IPv6 &#39;payload_length&#39; too large. The IPv6 header block &amp; payload size ({} bytes) is larger then what can be be represented by the &#39;payload_length&#39; field in the IPv6 header.&quot;</span>, <span class="ident">size</span>)
            },
            <span class="ident">UdpPayloadLengthTooLarge</span>(<span class="ident">length</span>) <span class="op">=</span><span class="op">&gt;</span> { <span class="comment">//usize</span>
                <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;UDP &#39;length&#39; too large. The UDP length ({} bytes) is larger then what can be be represented by the &#39;length&#39; field in the UDP header.&quot;</span>, <span class="ident">length</span>)
            }, 
            <span class="ident">TcpLengthTooLarge</span>(<span class="ident">length</span>) <span class="op">=</span><span class="op">&gt;</span> {  <span class="comment">//usize</span>
                <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;TCP length too large. The TCP packet length ({} bytes) is larger then what is supported.&quot;</span>, <span class="ident">length</span>)
            },
            <span class="ident">U8TooLarge</span>{<span class="ident">value</span>, <span class="ident">max</span>, <span class="ident">field</span>} <span class="op">=</span><span class="op">&gt;</span> {
                <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;The value {} of the field &#39;{}&#39; is larger then the allowed maximum of {}.&quot;</span>, <span class="ident">value</span>, <span class="ident">field</span>, <span class="ident">max</span>)
            },
            <span class="ident">U16TooLarge</span>{<span class="ident">value</span>, <span class="ident">max</span>, <span class="ident">field</span>} <span class="op">=</span><span class="op">&gt;</span> {
                <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;The value {} of the field &#39;{}&#39; is larger then the allowed maximum of {}.&quot;</span>, <span class="ident">value</span>, <span class="ident">field</span>, <span class="ident">max</span>)
            },
            <span class="ident">U32TooLarge</span>{<span class="ident">value</span>, <span class="ident">max</span>, <span class="ident">field</span>} <span class="op">=</span><span class="op">&gt;</span> {
                <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;The value {} of the field &#39;{}&#39; is larger then the allowed maximum of {}.&quot;</span>, <span class="ident">value</span>, <span class="ident">field</span>, <span class="ident">max</span>)
            }
        }
    }
}

<span class="doccomment">///Fields that can produce errors when serialized.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>, <span class="ident">Clone</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">ErrorField</span> {
    <span class="ident">Ipv4PayloadLength</span>,
    <span class="ident">Ipv4Dscp</span>,
    <span class="ident">Ipv4Ecn</span>,
    <span class="ident">Ipv4FragmentsOffset</span>,
    <span class="ident">Ipv6FlowLabel</span>,
    <span class="doccomment">///VlanTaggingHeader.priority_code_point</span>
    <span class="ident">VlanTagPriorityCodePoint</span>,
    <span class="doccomment">///VlanTaggingHeader.vlan_identifier</span>
    <span class="ident">VlanTagVlanId</span>,
}

<span class="kw">impl</span> <span class="ident">fmt</span>::<span class="ident">Display</span> <span class="kw">for</span> <span class="ident">ErrorField</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">fmt</span>::<span class="ident">Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">fmt</span>::<span class="prelude-ty">Result</span> {
        <span class="kw">use</span> <span class="ident">ErrorField</span>::<span class="kw-2">*</span>;
        <span class="kw">match</span> <span class="self">self</span> {
            <span class="ident">Ipv4PayloadLength</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;Ipv4Header.payload_len&quot;</span>),
            <span class="ident">Ipv4Dscp</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;Ipv4Header.differentiated_services_code_point&quot;</span>),
            <span class="ident">Ipv4Ecn</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;Ipv4Header.explicit_congestion_notification&quot;</span>),
            <span class="ident">Ipv4FragmentsOffset</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;Ipv4Header.fragments_offset&quot;</span>),
            <span class="ident">Ipv6FlowLabel</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;Ipv6Header.flow_label&quot;</span>),
            <span class="ident">VlanTagPriorityCodePoint</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;SingleVlanHeader.priority_code_point&quot;</span>),
            <span class="ident">VlanTagVlanId</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;SingleVlanHeader.vlan_identifier&quot;</span>)
        }
    }
}

<span class="kw">fn</span> <span class="ident">max_check_u8</span>(<span class="ident">value</span>: <span class="ident">u8</span>, <span class="ident">max</span>: <span class="ident">u8</span>, <span class="ident">field</span>: <span class="ident">ErrorField</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">ValueError</span><span class="op">&gt;</span> {
    <span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">ValueError</span>::<span class="ident">U8TooLarge</span>;
    <span class="kw">if</span> <span class="ident">value</span> <span class="op">&lt;</span><span class="op">=</span> <span class="ident">max</span> {
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(<span class="ident">U8TooLarge</span> { 
            <span class="ident">value</span>, 
            <span class="ident">max</span>,
            <span class="ident">field</span>
        })
    }
}

<span class="kw">fn</span> <span class="ident">max_check_u16</span>(<span class="ident">value</span>: <span class="ident">u16</span>, <span class="ident">max</span>: <span class="ident">u16</span>, <span class="ident">field</span>: <span class="ident">ErrorField</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">ValueError</span><span class="op">&gt;</span> {
    <span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">ValueError</span>::<span class="ident">U16TooLarge</span>;
    <span class="kw">if</span> <span class="ident">value</span> <span class="op">&lt;</span><span class="op">=</span> <span class="ident">max</span> {
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(<span class="ident">U16TooLarge</span>{ 
            <span class="ident">value</span>, 
            <span class="ident">max</span>, 
            <span class="ident">field</span>
        })
    }
}

<span class="comment">//NOTE: Replace this with std::Iterator::step_by as soon as it is in stable (see https://github.com/rust-lang/rust/issues/27741)</span>
<span class="kw">struct</span> <span class="ident">RangeStep</span> {
    <span class="ident">start</span>: <span class="ident">usize</span>,
    <span class="ident">end</span>: <span class="ident">usize</span>,
    <span class="ident">step</span>: <span class="ident">usize</span> 
}

<span class="kw">impl</span> <span class="ident">RangeStep</span> {
    <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">start</span>: <span class="ident">usize</span>, <span class="ident">end</span>: <span class="ident">usize</span>, <span class="ident">step</span>: <span class="ident">usize</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">RangeStep</span> {
        <span class="ident">RangeStep</span> {
            <span class="ident">start</span>,
            <span class="ident">end</span>,
            <span class="ident">step</span> 
        }
    }
}

<span class="kw">impl</span> <span class="ident">Iterator</span> <span class="kw">for</span> <span class="ident">RangeStep</span> {
    <span class="kw">type</span> <span class="ident">Item</span> <span class="op">=</span> <span class="ident">usize</span>;

    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">next</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> {
        <span class="kw">if</span> <span class="self">self</span>.<span class="ident">start</span> <span class="op">&lt;</span> <span class="self">self</span>.<span class="ident">end</span> {
            <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">start</span>;
            <span class="self">self</span>.<span class="ident">start</span> <span class="op">=</span> <span class="ident">result</span> <span class="op">+</span> <span class="self">self</span>.<span class="ident">step</span>;
            <span class="prelude-val">Some</span>(<span class="ident">result</span>)
        } <span class="kw">else</span> {
            <span class="prelude-val">None</span>
        }
    }
}</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="etherparse"></div>
    <script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script><script defer src="../../search-index.js"></script></body></html>