initSidebarItems({"constant":[["IPV6_MAX_NUM_HEADER_EXTENSIONS","Maximum number of header extensions allowed (according to the ipv6 rfc8200, & iana protocol numbers)."],["TCP_MAXIMUM_DATA_OFFSET","The maximum allowed value for the data offset (it is a 4 bit value)."],["TCP_MINIMUM_DATA_OFFSET","The minimum data offset size (size of the tcp header itself)."],["TCP_MINIMUM_HEADER_SIZE","The minimum size of the tcp header in bytes"],["TCP_OPTION_ID_END",""],["TCP_OPTION_ID_MAXIMUM_SEGMENT_SIZE",""],["TCP_OPTION_ID_NOP",""],["TCP_OPTION_ID_SELECTIVE_ACK",""],["TCP_OPTION_ID_SELECTIVE_ACK_PERMITTED",""],["TCP_OPTION_ID_TIMESTAMP",""],["TCP_OPTION_ID_WINDOW_SCALE",""]],"enum":[["ErrorField","Fields that can produce errors when serialized."],["EtherType","Ether type enum present in ethernet II header."],["InternetSlice",""],["IpHeader","Internet protocol headers version 4 & 6"],["IpTrafficClass","Identifiers for the traffic_class field in ipv6 headers and protocol field in ipv4 headers."],["LinkSlice","A slice containing the link layer header (currently only Ethernet II is supported)."],["ReadError","Errors that can occur when reading."],["TcpOptionElement","Different kinds of options that can be present in the options part of a tcp header."],["TcpOptionReadError","Errors that can occour while reading the options of a TCP header."],["TcpOptionWriteError","Errors that can occour when setting the options of a tcp header."],["TransportHeader","The possible headers on the transport layer"],["TransportSlice",""],["ValueError","Errors in the given data"],["VlanHeader","IEEE 802.1Q VLAN Tagging Header (can be single or double tagged)."],["VlanSlice","A slice containing a single or double vlan header."],["WriteError","Errors that can occur when writing."]],"mod":[["packet_filter",""]],"struct":[["DoubleVlanHeader","IEEE 802.1Q double VLAN Tagging Header"],["DoubleVlanHeaderSlice","A slice containing an double vlan header of a network package."],["Ethernet2Header","Ethernet II header."],["Ethernet2HeaderSlice","A slice containing an ethernet 2 header of a network package."],["Ipv4Header","IPv4 header without options."],["Ipv4HeaderSlice","A slice containing an ipv4 header of a network package."],["Ipv6ExtensionHeader","Dummy struct for ipv6 header extensions."],["Ipv6ExtensionHeaderSlice","A slice containing an ipv6 extension header of a network package."],["Ipv6Header","IPv6 header according to rfc8200."],["Ipv6HeaderSlice","A slice containing an ipv6 header of a network package."],["PacketBuilder","Helper for building packets."],["PacketBuilderStep","An unfinished packet that is build with the packet builder"],["PacketHeaders","Decoded packet headers (data link layer and higher). You can use PacketHeaders::from_ethernet_slice or PacketHeader::from_ip_slice to decode and get this struct as a result."],["SingleVlanHeader","IEEE 802.1Q VLAN Tagging Header"],["SingleVlanHeaderSlice","A slice containing a single vlan header of a network package."],["SlicedPacket","A sliced into its component headers. Everything that could not be parsed is stored in a slice in the field \"payload\"."],["TcpHeader","TCP header according to rfc 793."],["TcpHeaderSlice","A slice containing an tcp header of a network package."],["TcpOptionsIterator","Allows iterating over the options after a TCP header."],["UdpHeader","Udp header according to rfc768."],["UdpHeaderSlice","A slice containing an udp header of a network package. Struct allows the selective read of fields in the header."]],"trait":[["SerializedSize","Contains the size when serialized."]]});